--- 
title: "R-anvisningar till *Grundläggande statistik*"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
editor_options: 
  chunk_output_type: console
---

# Introduktion

Detta dokument är en kort introduktion till R för en kurs i grundläggande statistik.

```{r, echo = F}
knitr::opts_chunk$set(eval = T, message = F, warning = F, error = F, fig.height = 3.5, fig.align = "center")
```

```{r, echo = F}
rm(list = ls())
library(tidyverse)
select <- dplyr::select
```

```{r, echo = F}
library(knitr)
library(kableExtra)

kable <- function(x, digits = 4){
  x %>% 
    kbl(booktabs = T, digits = digits) %>% 
    kable_styling(full_width = F)
}
```

```{r, echo = F}
theme_set(theme_bw() + 
            theme(plot.background = element_rect(fill = "#f3eacb", color = "#f3eacb"),
                  text = element_text(family = "serif")))
```


<!--chapter:end:index.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Installation

## Inledning

För att köra R-kod på sin dator krävs en installation av programspråket R. För att effektivt arbeta i R används ofta en utvecklingsmiljö (ett tilläggsprogram som på flera sätt förenklar arbetet) och här ges anvisningar till den vanligaste utvecklingsmiljön för R, som är RStudio. För att komma ingång måste man alltså installera R och RStudio.

## Installation av R

Programspråket R kan laddas ner från https://www.r-project.org/ med följande steg:

1. Klicka på *CRAN* längst upp till vänster.
2. Klicka på den översta länken under 0-Cloud.
3. Välj en nedladdning beroende på operativsystem.
4. För Windows, välj *base*. För macOS, välj den senaste tillgängliga versionen.
5. Installera R från den nedladdade filen. Installation sker som för andra nedladdade program.

## Installation av RStudio

RStudio kan laddas ner från https://www.rstudio.com/ med följande steg:

1. Klicka på *Download* uppe till höger.
2. Scrolla nedåt och välj *Download* under *RStudio Desktop*.
3. Klicka på nedladdningsknappen.
4. Installera RStudio från den nedladdade filen. Installation sker som för andra nedladdade program.

## Gränssnittet i RStudio

När man nu öppnar RStudio ser man att fönstret är uppdelat i fyra delar och att varje del består av en eller flera flikar. De viktigaste är i nuläget

- *Console* där kod körs och resultat skrivs ut, 
- *Environment* där man ser skapade objekt,
- *History* där man ser tidigare körd kod,
- *Plots* där man ser skapade grafer, och
- *Help* där man ser hjälpsidor för funktioner.

Ofta skriver man inte sin kod direkt i konsollen, utan i ett separat *skript* - en vanlig textfil som innehåller den kod man vill köra. Genom att organisera sin kod i ett skript kan man lätt strukturera och dokumentera sitt arbete. I RStudio kan man öppna ett nytt skript genom att gå till *File > New File > R Script* eller genom att klicka *Ctrl + Shift + N*. Ett tomt skript öppnar sig då i det övre vänstra delfönstret. Om man skriver 

```{r}
a <- 5
```

i skriptet och trycker *Ctrl + Enter* bör man se att koden i skriptet körs i konsollen. Om man tittar i fliken *Environment* ska man också se att det nu skapats ett objekt *a*.

## Paket i R

En av de stora styrkorna med R är att språket kan byggas ut av dess användare. De här tilläggen kan sedan samlas i paket (*packages*) och delas med andra. Rs officiella bibliotek för paket kallas för *CRAN* (*Comprehensive R Archive Network*) och består av mer än 18 000 uppladdade paket som innehåller allt från fritt tillgänglig data till avancerade statistiska modeller. 

För att använda ett specifikt paket måste det först installeras. Om man vet namnet på paketet man vill installera kan man köra 

```{r, eval=F}
install.packages("tidyverse")
```

I det här fallet installeras paketet `tidyverse`, vilket innehåller funktioner för hantering av data.

I RStudio kan man också installera paket från *Packages*-fliken.

Paket måste också laddas för varje ny session. Innan man kan använda innehållet i ett paket måste man därför köra

```{r}
library(tidyverse)
```


<!--chapter:end:Rmd/Installation.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Datorövning 1. Datahantering och grafer

Datorövning 1 handlar om grunderna till R. Efter övningen ska vi kunna

- Starta RStudio och orientera oss i gränssnittet,

- Installera och ladda tilläggspaket (*Packages*)

- Definera objekt och tillämpa funktioner i R,

- Importera data från en online-källa,

- Transformera en tabell med data genom att välja kolumner, filtrera rader och summera per grupp,

- Skapa grafer med `ggplot2`.

## Uppstart och orientering

För att arbeta i R måste vi installera språket R och ett gränssnitt för att arbeta i R, vanligen *RStudio*. Titta på kapitlet *Installation* om programmen inte är installerade på ditt system.

Starta RStudio, till exempel genom att gå till Startmenyn och söka på RStudio eller genom att dubbelklicka på en fil som öppnas i RStudio. 
Gränssnittet i RStudio är uppdelat i fyra delar och varje del består av en eller flera flikar. De viktigaste är i nuläget

- *Console* där kod körs och resultat skrivs ut, 
- *Environment* där man ser skapade objekt,
- *History* där man ser tidigare körd kod,
- *Plots* där man ser skapade grafer, och
- *Help* där man ser hjälpsidor för funktioner.

::: {.exercise name="Help-fliken"}
Hitta fliken *Help*, klicka på husikonen under fliken. Finns det en länk med *RStudio Cheat Sheets*? Följ den länken för att hitta guider till R som kan bli nyttiga längre fram. För nu, gå tillbaka till RStudio.
:::

Ofta skriver man inte sin kod direkt i konsollen, utan i ett separat *skript* - en vanlig textfil som innehåller den kod man vill köra. Genom att organisera sin kod i ett skript kan man lätt strukturera och dokumentera sitt arbete. I RStudio kan man öppna ett nytt skript genom att gå till *File > New File > R Script* eller genom att klicka *Ctrl + Shift + N*. Ett tomt skript öppnar sig då i det övre vänstra delfönstret. Om du läser det här i RStudio, genom att ha laddat ner .R-filen, läster du just nu ett skript.

::: {.exercise name="Ett första skript"}
Öppna ett nytt skript genom File-menyn eller genom *Ctrl + Shift + N*.
Skriv

```{r}
a <- 5
```

i skriptet och tryck *Ctrl + Enter*. Titta i flikarna *Console* och *Environment*. Har något hänt? Du bör se att koden i skriptet körts i konsollen och att ett nytt objekt `a` ligger i *Environment*.
:::

## *Packages* från CRAN

En av de stora styrkorna med R är att språket kan byggas ut av dess användare. De här tilläggen kan sedan samlas i paket (*packages*) och delas med andra. Rs officiella bibliotek för paket kallas för *CRAN* (*Comprehensive R Archive Network*) och består av mer än 18 000 uppladdade paket som innehåller allt från fritt tillgänglig data till avancerade statistiska modeller. 

För att använda ett specifikt paket måste det först installeras. Om man vet namnet på paketet man vill installera kan man köra 

```{r, eval=F}
install.packages("tidyverse")
```

I det här fallet installeras paketet `tidyverse`, vilket innehåller funktioner för hantering av data.

I RStudio kan man också installera paket från *Packages*-fliken.

::: {.exercise name="Installera tidyverse-paketet"}
Kör raden ovan för att installera `tidyverse`. Du kan antingen köra raden genom att skriva den i *Console* eller genom att skriva i ett skript och köra därifrån genom *Ctrl + Enter*.
:::

::: {.exercise name="Installera gapminder-paketet"}
Paketet `gapminder` innehåller lite intressant data vi kommer använda senare. Installera paketet `gapminder` genom att fylla i och köra raden nedan.

```{r, eval = F}
install.packages("___")
```
:::

Paket måste också laddas för varje ny session. Innan man kan använda innehållet i ett paket måste man därför köra

```{r}
library(tidyverse)
```

::: {.exercise name="Ladda gapminder-paketet"}
Ladda paketet `gapminder` genom att fylla i och köra raden nedan.

```{r, eval = F}
library(___)
```
:::

::: {.exercise name="Paket som inte finns"}
Vad händer om man försöker installera ett paket som inte finns på *CRAN* ? Testa till exempel

```{r, eval = F}
install.packages("ThisIsNotTheNameOfAnyPackage")
```

och

```{r, eval = F}
library(ThisIsNotTheNameOfAnyPackage)
```
:::

## Objekt och funktioner

Ett *objekt* i R är en namngiven informationsmängd. Objekt kan se ut på många olika sätt - under kursens gång används objekt som består av insamlad data (konstruerade som vektorer eller tabeller), objekt som är statistiska modeller, och flera andra former. I R skapar man objekt med *assign*-pilen `<-` (mindre än och bindestreck).

I ett tidigare exempel fanns raden

```{r}
a <- 5
```

Här skapas ett objekt med namnet `a` som innehåller informationen `5`. *Assign*-pilen pekar alltså på det namn man vill ge objektet och pekar från objektets innehåll.

Ett lite mer komplicerat exempel på ett objekt ges av

```{r}
b <- c(3, 1, 4, 1, 5, 9)
```

Här skapas ett objekt `b` som innehåller en *serie* numeriska värden (en *vektor*).

::: {.exercise name="Skapa en vektor"}
Skapa ett objekt med namnet `new_vector` som innehåller värden 5, 7 och 10 genom att fylla i följande rad.

```{r, eval = F}
new_vector <- c(_, _, _)
```
:::

Objekt kan manipuleras genom att tillämpa *funktioner*. En funktion tar någon ingående data och ger något utgående resultat. Funktioner anges genom att skriva funktionens namn följt av ingående data inom parenteser, och resultatet kan antingen skrivas ut i konsollen eller sparas som ett nytt objekt. En grundinstallation av R innehåller en mängd färdiga funktioner, t.ex.

```{r}
sum(b)
```

vilket ger summan av värdena i vektorn `b`,

```{r}
plot(b)
```

som ger en simpel graf, och

```{r}
sqrt(b)
```

som beräknar kvadratroten för varje element i vektorn.

::: {.exercise name="Summera vektorn"}
Fyll i och kör följande rad för att beräkna summan av vektorn `new_vector`

```{r, eval = F}
sum(___)
```
:::

Vid konstruktionen av vektorn användes också en grundläggande funktion - funktionen `c` som tar en serie värden och skapar en sammanhängande vektor av värden.

Alla R-funktioner har en tillhörande hjälpfil som kan plockas fram genom att skriva frågetecken följt av funktionsnamnet, t.ex. `?sum`. Från hjälpfilen får man att `sum` tar numeriska vektorer som ingående värde och beräknar summan. Man kan styra funktionens beteende genom att sätta ett argument `na.rm` (vilket här styr hur funktionen hanterar saknade värden). Som illustration kan man titta på

```{r}
b <- c(3, 1, 4, 1, 5, 9, NA)  # Lägger till ett saknat värde
sum(b)                        # na.rm = FALSE är grundinställning
sum(b, na.rm = TRUE)          # na.rm sätts till TRUE
```

Det första försöket `sum(b)` ger utfallet `NA`, men om man sätter `na.rm = TRUE` beräknas summan efter att det saknade värdet plockats bort. Notera också att skript kan kommenteras med `#`.

## Sekvenser av funktioner

Ofta vill man genomföra flera operationer på ett objekt. Man behöver då genomföra en sekvens av funktioner. Säg till exempel att man har värdena $$(-4, -2, -1, 1, 2, 4)$$ och vill ta absolutvärde (vilket gör negativa tal till motsvarande positiva tal) och sedan summera.
Den typen av sekvenser kan genomföras på ett par olika sätt. Ett första sätt är att spara resultatet i varje steg och sedan använda utfallet i nästa steg:

```{r}
c <- c(-4, -2, -1, 1, 2, 4)
c_absolute <- abs(c)
sum(c_absolute)
```

Här skapas ett objekt `c` som innehåller en vektor där några tal är negativa. I nästa rad används `abs` för att skapa absolutvärden. Slutligen summeras absolutvärdena med `sum`.
Notera att det är möjligt att skapa ett objekt med namnet `c` trots att det redan är namnet på en funktion - R förstår ur sammanhanget om objektet eller funktionen ska användas.

::: {.exercise name="Kvadrat, summa och roten ur"}
Fyll i och kör följande rader för att ta varje värde i `new_vector` i kvadrat, *sedan* summera, och sedan ta roten ur.

```{r, eval = F}
new_vector_squared <- new_vector^2 # Ta kvadraten av varje värde
new_vector_squared_sum <- sum(___) # Summera vektorn med kvadrater
sqrt(___)                          # Ta kvadratroten ur summan
```
:::

Ett alternativ är att skriva en senare funktion *runt* en tidigare funktion. Det fungerar för att R utvärderar funktioner inifrån-ut. Med samma exempel som tidigare får man

```{r, eval=F}
sum(abs(c(-4, -2, -1, 1, 2, 4)))
```

medan beräkningen i övningen blir

```{r, eval=F}
sqrt(sum(new_vector^2))
```

Den här typen av skrivning kan spara plats men blir snabbt svårläst.

Ett sista alternativ är att använda en så kallad *pipe* (namnet kommer från att en sekvens funktioner kallas en *pipeline*). En pipe skrivs `%>%` och tar utfallet av en funktion till vänster och sänder till en funktion till höger. Språkligt kan pipen utläsas *och sen*. Funktionen kan laddas genom att ladda paketet `tidyverse`. Med samma exempel som tidigare kan vi skriva

```{r}
library(tidyverse)

c(-4, -2, -1, 1, 2, 4) %>%  # Skapa en datamängd och sen
  abs() %>%                 # ta absolutvärden, och sen
  sum()                     # beräkna summan.
```

::: {.exercise name="Kvadrat, summa och rot med pipe"}
Fyll i de saknade funktionerna och kör följande rader för att ta varje värde i `new_vector` i kvadrat, *sedan* summera, och sedan ta roten ur, denna gång genom att länka funktionerna med en pipe `%>%`.

```{r, eval = F}
new_vector^2 %>%        # Ta kvadraterna av new_vector, och sen
  ___() %>%             # beräkna summan, och sen
  ____()                # Ta kvadratroten (med sqrt())
```
:::

## Datainskrivning och dataimport från web

### Inskrivning av data

Det första praktiska steget i en statistisk analys är att importera data. I R kan det göras genom att direkt skriva in sin data och spara som ett nytt objekt, men ett bättre och vanligare sätt är att importera sin data från en extern fil eller databas.

I ett tidigare exempel användes funktionen `c` för att skapa en vektor av data. Ofta ordnas flera vektorer i en tabell där varje kolumn är en vektor och varje rad en observation av någon enhet. En datatabell (en `data.frame` i R) skapas genom funktionen `data.frame()` följt av namngivna vektorer. Exempeldata kan skrivas in genom föjande.

```{r}
dat <- data.frame(Vecka = c(7,7,7,7,7,7,11,11,11,11,11,11),
                  Behandling = c("A","A","A","B","B","B","A","A","A","B","B","B"),
                  Vikt = c(232,161,148,368,218,257,1633,2213,972,2560,2430,855),
                  N = c(2.63,2.90,2.99,3.54,3.30,2.85,1.53,1.90,NA,2.58,NA,NA))

dat
```

Radbrytningar och blanksteg är oviktiga i R, och används bara för läsbarhet här. Saknade värden skrivs in som `NA`  för *not available*. Notera att alla kolumner inte behöver vara av samma datatyp men att värden inom en kolumn måste vara det. Här är *Behandling* text medan övriga kolumner är numeriska.

::: {.exercise name="Alea iacta est"}
Kasta din tärning tio gånger och skriv in resultatet i en datatabell i R med hjälp av grundkoden nedan. Om du saknar en tärning, fråga lämplig person om du kan få en. Behåll tärningen, den behövs till nästa datorövning (och närhelst man står inför ett avgörande livsbeslut).

```{r, eval = F}
dat_dice <- data.frame(Kast = c(1,2,3,4,5,6,7,8,9,10),
                       Utfall = c(_,_,_,_,_,_,_,_,_,_))
dat_dice
```
:::

### Import från en extern fil

Inskrivning av värden är ofta tidskrävande och kan lätt leda till misstag. Det är därför mycket vanligare att data läses in från en extern fil. Det finns en mängd funktioner för dataimport och det exakta valet av funktion beror på vilken typ av fil datan är sparad i. Ett vanligt filformat är .csv (*comma separated values*). Här importerar vi en fil med data från Spotify.

```{r}
dat <- read_csv("https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Spotify_data.csv")
dat
```

Om importen fungerat kan man skriva ut tabellens översta rader genom att köra objektets namn.

För att snabbt se vilka artister datan täcker kan man köra

```{r, eval=F}
unique(dat$artist_name)
```

där `unique` är en funktion som tar bort alla dubletter och `dat$artist_name` används för att plocka ut kolumnen `artist_name` ur tabellen `dat`.

## Transformera en tabell med `select`, `filter`, `mutate` och `summarise`

### Urval med `select` och `filter`

En vanlig operation på en tabell är att göra ett urval - antingen ett urval av rader (t.ex. en viss artist), vilket kallas *filtrering* eller ett urval av variabler (t.ex. artist och albumnamn), vilket kallas *selektion*.
Det finns flera olika sätt att göra ett urval i R. 
Det traditionella sättet är att använda index inom hakparenteser (t.ex. `dat[4, 2]` för fjärde raden, andra kolumnen) eller dollartecken för specifika kolumner (t.ex. `dat$artist_name` för artistnamn).
Här fokuseras dock på hur det kan göras med funktionerna `filter` och `select` från paketet `tidyverse`.

För att filtrera på ett givet land kan använda pipe-funktionen från datan till en filter-funktion, t.ex.

```{r}
dat %>%                          # Ta spotify-datan och sen
  filter(artist_name == "Robyn") # filtrera för en specifik artist
```

Inom filter-funktionen anges ett logisk villkor `country == "Sweden"` och utfallet är de rader där villkoret är sant. Notera de dubbla likhetstecknen - de måste användas för ett logisk villkor eftersom enkelt likhetstecken används för att skapa objekt och sätta funktionsargument. 

::: {.exercise name="Filtrera för artist"}
Vad måste ändras i koden för att istället plocka ut rader där artisten är Esperanza Spalding? Hur många rader har det urvalet?

```{r, eval = F}
dat %>%                          # Ta spotify-datan och sen
  filter(artist_name == "Robyn") # filtrera för en specifik artist
```
:::

Om man vill välja flera artister kan man använda funktionen `%in%` på ett liknande sätt.

```{r, eval=F}
dat %>% 
  filter(artist_name %in% c("Robyn", "Esperanza Spalding"))
```

och om man vill ha mer än ett villkor kan man rada dem i filter-funktionen eller ha flera filter-steg:

```{r, eval=F}
dat %>% 
  filter(artist_name %in% c("Robyn", "Esperanza Spalding"),
         key_name == "D#")
```

alternativt

```{r, eval=F}
dat %>% 
  filter(artist_name %in% c("Robyn", "Esperanza Spalding")) %>% 
  filter(key_name == "D#")
```

För att se fler eller färre rader kan man använda en pipe `%>%` till funktionen `print`. Följande skriver ut fem rader

```{r}
dat %>% 
  filter(artist_name %in% c("Robyn", "Esperanza Spalding")) %>% 
  filter(key_name == "D#") %>% 
  print(n = 5)
```

Om man istället vill göra ett urval av kolumner kan man använda `select`. Som argument anges de kolumner man vill välja, t.ex.

```{r}
dat %>% 
  select(artist_name, album_name)
```

Som avslutning ges ett lite mer komplicerat exempel på ett urval av artist, år och spår för spår med ett tempo över 180 bpm släppta under 2015.

```{r}
dat %>%                                               # Ta datan och sen
  filter(album_release_year == 2015,                  # filtrera för rader där år är 2015, och 
         tempo > 180) %>%                             # tempot över 160, och sen
  select(artist_name, album_release_year, track_name) # selektera på artist, år och spår
```

::: {.exercise name="Snabba spår"}
Funktionen `arrange` sorterar data efter en angiven kolumn. Följande stycke ger oss Björks snabbaste spår. 

```{r, eval = F}
dat %>%                                                   # Ta datan, och sen
  filter(artist_name == "Björk") %>%                      # filtrera för rader där artist är Björk, och sen
  select(artist_name, album_name, track_name, tempo) %>%  # välj kolumner med artist, album, spår och tempo, och sen
  arrange(-tempo)                                         # ordna efter tempo (minus för fallande ordning)
```

Gör lämpliga ändringar för att hitta Kate Bushs snabbaste spår. Gör ytterligare ändringar för att hitta Daft Punks långsammaste spår.
:::

### Ändra och skapa nya kolumner med `mutate`

Variabler kan omräknas och nya variabler kan skapas med `mutate`-funktionen. I spotify-datan finns tempo som slag per minut. Om man vill ha slag per sekund kan man skapa en nya kolumn och beräkna den som tempo delat på 60.

```{r}
dat <- dat %>% 
  mutate(beats_per_second = tempo / 60)
```

Den inledande delen med `dat <-` gör så att utfallet av beräkningen sparas i objektet `dat`.
Vi kan skriva ut objektet och se resultatet av beräkningen:

```{r}
dat %>% select(tempo, beats_per_second)
```

::: {.exercise name="Glädje per dansbarhet"}
Följande stycke beräknar kvoten av kolumnerna valence och danceability i en ny kolumn `valence_to_danceability.

```{r, eval = F}
dat %>%                                                        # Ta datan, och sen
  mutate(valence_to_danceability = valence / danceability) %>% # beräkna valence delat på danceability, och sen
  select(valence, danceability, valence_to_danceability)       # välj relevanta kolumner.
```

Gör lämpliga ändringar för att multiplicera `tempo` och `time signature`. Ett passande namn för den nya kolumnen kan vara `tempo_times_time_signature`.
:::

I exemplet och uppgiften ovan skapades nya kolumn namn med understreck `_` istället för mellanrum. Om man vill ha mellanrum i sina kolumnnamn måste man skriva namnet inom *backticks* `\`` för att ange att namnet ska tolkas som en enhet.

```{r}
dat %>% 
  mutate(`Valence to danceability` = valence / danceability) %>% # Namnet Valence to danceability skrivs inom backticks
  select(artist_name, `Valence to danceability`)
```

### Summera kolumner med `group_by` och `summarise`

För att presentera insamlad data på ett tolkningsbart sätt används sammanfattande mått såsom summor, medelvärden, medianer och standardavvikelser. 
Den typen av beräkningar kan göras som ett nytt steg i en pipe med hjälp av funktionen `summarise`. Om man kombinerar `summarise` med funktionen `group_by` kan man dessutom summera efter en indelning given av en annan variabel. En beräkning av genomsnittligt tempo per år kan till exempel ges av

```{r}
dat %>%                                       # Ta datan, och sen
  group_by(album_release_year) %>%            # gruppera efter år, och sen
  summarise(Medeltempo = mean(tempo))         # beräkna medelvärde av tempo
```

I det sista steget skapas en variabel *Medeltempo* som ges av medelvärde av den ursprungliga variabeln *tempo*. Här använder vi också funktionen `mean` för att beräkna medelvärdet.

Om man vill summera flera variabler kan man ange flera beräkning inom `summarise`, t.ex.

```{r}
dat %>%                                   # Ta datan, och sen
  group_by(album_release_year) %>%        # gruppera efter år, och sen
  summarise(Medeltempo = mean(tempo),     # beräkna medelvärde av tempo
            Medelvalence = mean(valence), # beräkna medelvärde av valence
            antal_spår = n()) %>%         # beräkna antalet spår, och sen
  arrange(-Medelvalence)                  # ordna efter medelvalence i sjunkande ordning
```

::: {.exercise name="Gladast artist"}
Vad ska ändras i stycket ovan för att beräkna medelvalence per artist istället för per år?

Funktionen `count()` ger antalet rader uppdelat efter valfri kolumn. Den kan användas som en kortform för `group_by()` och `summarise()`. Vad måste ändras i stycket nedan för att se vilka artister som påverkar värdet för 1960?

```{r, eval=F}
dat %>%                                              # Ta data, och sen
  filter(album_release_year == 1976) %>%             # ta ut rader där år är 1976, och sen
  count(artist_name, album_name, album_release_year) # räkna antalet rader per artist, album och år
```
:::

## Grafer med `ggplot2`

Vi kan nu börja titta på grafer. Eftersom datan är ganska stor och grafer lätt blir oöversiktliga, börjar vi med att skapa en lite mindre datamängd.

```{r}
dat_small <- dat %>% 
  filter(artist_name == "Robyn", album_type == "album")
```

::: {.exercise name="Valfritt artistbyte"}
Om du vill titta data på något annan artist, gör lämplig ändring i stycket ovan. Kom ihåg att man skriva ut artister i datan med `unique(dat$artist_name)`.
:::

R har en mängd grundläggande funktioner för grafer. Ett enkelt spridningsdiagram kan till exempel skapas med

```{r}
plot(x = dat_small$tempo, y = dat_small$danceability)
```

Tecknet `$` används här för att välja en kolumn i en tabell.

För mer avancerade grafer används dock ofta funktioner ur Rs paketbibliotek. Här illustreras det mest populära - `ggplot2`. I `ggplot2` byggs grafer upp med tre grundläggande byggstenar: 

- *data*, informationen man vill visualisera,
- *aestethics*, en koppling mellan data och visuella element såsom grafens axlar, objekts storlek och färg,
- *geometries*, de geometriska former som visas i grafen.

En graf skrivs med en startfunktion `ggplot` som anger namnet på datan och grafens *aestethics*, och därefter sätts geometriska element genom funktioner som börjar med `geom_`. Ett spridningsdiagram kan t.ex. skapas med `geom_point`.

```{r}
ggplot(dat_small, aes(x = tempo, y = danceability)) +
  geom_point()
```

Grafen kan byggas ut genom att sätta *aestethics*  för färg och storlek. Man kan också dela en graf i småfönster med `facet_wrap` och styra grafens utseende genom att sätta ett tema såsom `theme_bw`.

```{r, fig.height=6}
ggplot(dat_small, aes(x = tempo, y = danceability, color = mode_name)) +
  geom_point() +
  facet_wrap(~ album_name)
```

::: {.exercise name="Dur och moll"}
Vad ska ändras i stycket nedan för att skapa en graf med dur/moll (`mode_name`) på x-axeln, valens (`valence`) på y-axeln och skilda småfönster för olika år (`album_release_year`)?

```{r, eval = F}
ggplot(dat_small, aes(x = mode_name, y = valence, color = album_name)) +
  geom_point() +
  facet_wrap(~ album_release_year)
```

Har spår i dur (*major*) högre valens?
:::

Andra graftyper kan skapas med andra `geom_`-funktioner. För ett linjediagram används `geom_line`. De observationer som ska ge en specifik linje anges med `group` i `aes`-funktionen. Låt oss beräkna medeldansbarhet över tid, uppdelat efter markeringen för *explicit* (alltså om spåret är barnvänligt eller inte). Exemplet visar också hur man använda flera geometrier genom att lägga till dem efter varandra med `+`.

```{r}
dat_mean_over_time <- dat %>% 
  group_by(album_release_year, explicit) %>% 
  summarise(Mean_danceability = mean(danceability))

ggplot(dat_mean_over_time, aes(x = album_release_year, y = Mean_danceability, color = explicit)) +
  geom_line() +
  geom_point()
```

Här ger färgen uppdelningen i explicit och icke-explicit (`TRUE` för explicit). Det finns också spår som saknat värde för explicit och därför blir `NA` här. Kan vi utifrån grafen säga att barnvänlig musik är mer eller mindre dansbar än icke-barnvänlig?

::: {.exercise name="Explicit glädje"}
Vad ska ändras i stycket ovan för att för en graf över medelvalens (`valence`) istället för dansbarhet? Är barnvänlig musik gladare eller ledsnare är icke-barnvänlig?
:::

Stapeldiagram ges av `geom_col` (`col` för *column*). Man kan också använda `geom_bar` om man bara vill räkna antal rader per någon kategori. Följande beräknar valens per artist, ordnar efter valens, väljer ut de tjugo högsta, och plottar i ett (liggande) stapeldiagram.

```{r}
dat %>%                                                                  # Ta datan, och sen
  group_by(artist_name) %>%                                              # gruppera efter artist, och sen
  summarise(Mean_valence = mean(valence)) %>%                            # ta medelvärdet av valence, och sen
  arrange(-Mean_valence) %>%                                             # ordna efter medelvalens (minustecken för sjunkande ordning), och sen
  slice(1:20) %>%                                                        # ta ut de tjugo första raderna
  ggplot(aes(x = Mean_valence, y = artist_name, fill = Mean_valence)) +  # starta en ggplot där x-axeln ges av valens och y-axeln av artist, och sen
  geom_col(color = "black")                                              # skapa en geometri av kolumner
```

Argumentet `fill` styr färgen för ytor (här staplarnas ytor) medan `color` i `geom_col()` styr kanten runt varje stapel.

Man kan styra grafiken i en `ggplot` genom funktionen `theme()`. Det är ett ganska komplicerat ämne, men låt oss titta på några grunder. Vi börjar med att skapa en enkel graf: en boxplot över dansbarhet per album för bandet *Beach House*.

```{r}
dat_small <- dat %>% filter(artist_name == "Beach House", album_type == "album")

ggplot(dat_small, aes(danceability, album_name)) +
  geom_boxplot()

```

Vi kan ändra utseendet på grafen genom argument inom geometrier och med funktionen `theme()`. I `theme()` sätter man de specifika egenskaper man vill ändra genom att tillskriva dem ett *element*. Valet av element beror på typen av grafiskt objekt - text sätts t.ex. med `element_text()` och ytor med `element_rect()` (för *rectangle*). Vi ger ett exempel med ändrad bakgrund, rutmönster, och teckenstorlek.

```{r}
ggplot(dat_small, aes(danceability, album_name)) +
  geom_boxplot(fill = "lightblue") +
  theme(panel.background = element_rect(fill = "red3"), 
        text = element_text(size = 15, color = "white", family = "serif"),
        axis.text = element_text(color = "white"),
        plot.background = element_rect(fill = "grey30", color = "black"),
        panel.grid.major.y = element_blank())
```

::: {.exercise name="Temaval 1"}
Ändra färgvalen i grafen ovan för att skapa snyggast möjliga graf. Funktionen `colors()` ger de färger som finns tillängliga i R. Man kan också använda hex-koden för färger, t.ex. `fill = "#ffdd00"`.
:::

::: {.exercise name="Temaval 2"}
Ändra färgvalen i grafen ovan för att skapa fulast möjliga graf. Visa de två graferna för någon annan och se om de kan säga vilken som är vilken.
:::

## Bonus: interaktiva grafer med `plotly`

Låt oss ta en titt på `plotly`, ett av flera R-paket som gör det möjligt att skapa interaktiva grafer. Vi börjar med att installera och ladda paketet.

```{r, eval=F}
# install.packages("plotly")
library(plotly)
```

Paketet innehåller en smidig funktion `ggplotly()` för att göra en interaktiv graf från en `ggplot`. Vi börjar med att filtrera datan för en specifik artist och albumtyp. I samma pipe skapar vi en ny kolumn decade, som beräknar årtiondet utifrån året. Den exakta beräkning är inte så viktig, men ta gärna en titt och se om du förstår vad som delarna gör.

```{r, eval=F}
dat_small <- dat %>% 
  filter(artist_name == "David Bowie", album_type == "album") %>% 
  mutate(Decade = floor(album_release_year / 10) * 10)
```

(Säg t.ex. att vi har året 1979. Att dela med 10 ger 197.9. Funktionen `floor` avrundar nedåt till 197. Multiplikationen med 10 ger 1970.)

Vi kan nu konstruera en graf med `ggplot()`. Låt oss ha dansbarhet på x-axeln och valens på y-axeln. Geomet `geom_point()` ger ett spridningdiagram och `facet_wrap(~ Decade)` delar i småfönster efter årtionde. Slutligen tar `theme(legend.position = "none")` bort *legenden* - guiden som anger vilken färg som är vilket album.

Notera att vi sparar grafen som ett objekt `g`. För att se grafen kör vi objektnamnet.

```{r, eval=F}
g <- ggplot(dat_small, aes(danceability, valence, color = album_name, text = track_name)) +
  geom_point() +
  facet_wrap(~ Decade) +            # Skapar småfönster per årtionde
  theme(legend.position = "none")   # Tar bort legenden (kopplingen mellan färg och album)
g
```

När vi har en färdig ggplot kan `ggplotly()` ge en interaktiv version av samma graf.

```{r, eval=F}
ggplotly(g)
```

::: {.exercise name="Interaktiv graf med annan artist"}
Gör lämpliga ändringar i stycket nedan för att skapa en interaktiv graf med en annan artist och med tempo på x-axeln och dansbarhet på y-axeln. Kom ihåg att du kan se tillgängliga artister med raden `unique(dat$artist_name)`.

```{r, eval = F}
dat_small <- dat %>% 
  filter(artist_name == "David Bowie", album_type == "album") %>% 
  mutate(Decade = floor(album_release_year / 10) * 10)

g <- ggplot(dat_small, aes(danceability, valence, color = album_name, text = track_name)) +
  geom_point() +
  facet_wrap(~ Decade) +            # Skapar småfönster per årtionde
  theme(legend.position = "none")   # Tar bort legenden (kopplingen mellan färg och album)
g

ggplotly(g)
```
:::

::: {.exercise name="Interaktiv graf med andra axlar"}
Vi fortsätter med ett nytt exempel, nu med ett spridningsdiagram med album på y-axeln och valens på x-axeln.

```{r}
dat_small <- dat %>% 
  filter(artist_name == "Rihanna", album_type == "album") %>% 
  mutate(Decade = floor(album_release_year / 10) * 10,
         Decade = as.character(Decade),
         album_name = reorder(album_name, album_release_year)) # Funktionen reorder() ordnar en vektor efter en annan. Här ordnas album efter release-år.

g <- ggplot(dat_small, aes(valence, album_name, color = Decade, text = track_name)) +
  geom_point()
g
```

Ändra gärna artist på lämpligt ställe.
Vad måste läggas till för en interaktiv version av samma graf?
:::

Hemsidan https://plotly.com/r/ innehåller fler exempel för den som är intresserad.

## Bonus: Warming stripes

*Warming stripes* har sedan de först introducerades av Ed Hawking 2018 blivit en vanlig illustration av temperaturökning. I en warming stripe-graf anges varje år av en stapel och stapels färg ges av ett temperaturmått, vanligen årets medeltemperatur. I ggplot-terminologi har vi geometrier (staplar eller kolumner) med en x-position som ges av år och en ifylld färg som ges av temperatur.

För att göra en graf behöver vi data över temperaturer. Följande rad hämtar temperaturdata från Stockholm. Källa: https://miljobarometern.stockholm.se/klimat/klimat-och-vaderstatistik/medeltemperatur/

```{r}
dat_temp <- read_csv("https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Temperatur%2C%20Stockholm.csv")
```

Vi skapar nu en graf, som alltså ska ha en x-axeln given av år  (`Year`) och ifylld färg som ges av temperatur (`Value`). Höjden ska vara densamma för alla staplar, men det spelar ingen roll vad den är (så länge den inte är noll).

```{r}
ggplot(dat_temp, aes(x = Year, y = 1, fill = Value)) +
  geom_col()
```

::: {.exercise name="Staplar utan mellanrum"}
Ett första problem är att staplarna inte fyller ytan. Man kan styra staplars bredd med argumentet `width`, t.ex.

```{r, eval = F}
ggplot(dat_temp, aes(x = Year, y = 1, fill = Value)) +
  geom_col(width = 0.1)
```

Hitta ett värde för `width` som ger staplar utan mellanrum.
:::

::: {.exercise name="Färgval"}
Ett andra problem är att ggplots grundval för färger är från svart till blått. För klassiska warming stripes vill vi ha en skala från blått till rött. Färgerna i en skala ändras med särskilda `scale_()`-funktioner. En färgskala för ifylld färg kan sättas med `scale_fill_gradientn()`, till exempel

```{r, eval = F}
ggplot(dat_temp, aes(x = Year, y = 1, fill = Value)) +
  geom_col(width = 0.1) +
  scale_fill_gradientn(colours = c("darkgreen", "blue", "white", "yellow", "purple"))
```

Välj färger som ger en naturlig skala från blått till rött. Funktionen `colors()` ger valbara färger i R. Några möjliga val kan vara `darkblue`, `blue`, `white`, `red`, `salmon`, `darkred`, `steelblue` och `skyblue`.
:::

::: {.exercise name="Enkel graf"}
Slutligen brukar warming stripes presenteras med så lite kringinformation som möjligt. I ggplot kan grafelement tas bort med `theme()`. Här är som exempel en graf utan y-axel, tickmärken och legend.

```{r, eval = F}
ggplot(dat_temp, aes(x = Year, y = Value)) +
  geom_line() +
  theme(axis.title = element_blank(), 
        legend.position = "none",
        plot.background = element_blank(),
        panel.background = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank())
```

Använd temat från exemplet för att skapa en enklare version av grafen från föregående uppgift.
:::

## Valfria hemuppgifter

::: {.exercise name="Installera R"}
Gå till https://www.r-project.org/ och installera R på ditt hemma-system. Instruktioner finns i R-anvisningarnas kapitel *Installation*.
:::

::: {.exercise name="Installera RStudio"}
Gå till https://www.rstudio.com/ och installera RStudio på ditt hemma-system. Instruktioner finns i R-anvisningarnas kapitel *Installation*.
:::

::: {.exercise name="Öppna RStudio"}
Öppna skriptet till datorövning 1 i RStudio. Notera om något ser annorlunda ut mot hur det såg ut i datorsal.
:::

::: {.exercise name="Cheat sheets"}
I början av datorövning 1 plockade vi upp en hemsida med *cheat sheets* - korta instruktioner och guider till specifika R-paket. Vi kan hitta några av dem på https://www.rstudio.com/resources/cheatsheets/.
Ladda ner guiden till `ggplot2`. Hur många olika `theme_()`-funktioner (som t.ex. `theme_bw()`) beskrivs i guiden? Vad gör en `theme_`-funktion?
:::

::: {.exercise name="Timothée Chalamet"}
Hitta klippet där skådespelaren Timothée Chalamet sjunger en sång om statistik. Uppskatta spårets dansbarhet och valens på en skala från noll till ett. Fundera på om det är rimligt att sätta en siffra på dansbarhet och valens.
:::

<!--chapter:end:Rmd/Datorövning-1.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Datorövning 2. Beskrivande statistik

Datorövning 2 handlar om beräkning av beskrivande statistik i R. Efter övningen ska vi kunna

- Importera data från en excelfil,

- Beräkna lämpliga lägesmått för en variabel,

- Beräkna lämpliga spridningsmått för en variabel,

- Konstruera grafer som jämför två eller flera gruppers läge och spridning.

## Repetition från datorövning 1

När man arbetar i R är det klokt att använda ett avancerat gränssnitt som RStudio och att skriva sin kod i ett separat skript. I RStudio kan man starta ett nytt skript genom *Ctrl + Shift + N*.

Mycket funktionalitet i R ligger i tilläggspaket (*Packages*). Paket måste installeras första gången de används och laddas varje session de används, t.ex.

```{r}
# install.packages("tidyverse")
library(tidyverse) # Ger ett felmeddelande om paketet inte installerats tidigare.
```

Data läses in med import-funktioner där valet av funktion beror på typen av fil. Importerad data sparas som ett objekt i R genom *assign*-pilen `<-`.

```{r}
dat <- read_csv("https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Spotify_data.csv")
dat
```

Funktioner agerar på objekt och ger något utfall. Här beräknas medeltempot med funktionen `mean()`. Dollartecknet används för att ange en specifik kolumn i dataobjektet. Funktioner styrs av möjliga argument - här används `na.rm` för att ange att saknade värden inte ska tas med i beräkningen

```{r}
mean(dat$tempo, na.rm = T)
```

Funktionerna `filter()` och `select()` kan användas för att välja kolumner och rader. Funktioner kan länkas samman med en pipe `%>%` för att skapa sekvenser av funktioner. Man kan tänka på pipen som *och sen*.

```{r}
dat %>%                                                 # ta datan, och sen
  filter(artist_name == "Tame Impala", tempo > 170) %>% # ta ut rader där artisten är Tame Impala och tempot är större än 170, och sen
  select(artist_name, track_name, tempo)                # ta ut kolumnerna artist_name, track_name och tempo
```

Funktionen `summarise()` ger ett sammanfattande mått (som `mean()` för medelvärde eller `sum()` för summa) för någon eller några variabler. Funktionen `group_by()` kan användas för att göra beräkningen efter någon gruppering.

```{r}
dat %>% 
  group_by(artist_name) %>% 
  summarise(Antal_spår = n(),
            Medeltempo = mean(tempo),
            Maxdansbarhet = max(danceability))
```

Slutligen tittade vi på grafer med ggplot2-paketet. En ggplot byggs upp med tre grundelar: data, geometrier (grafens objekt och former), och *aesthetics* (utseende och placering av geometrierna). I ett enkelt spridningsdiagram är data två numeriska variabler, geometrierna är punkter, och punkternas placering ges av en x-koordinat och en y-koordinat. Ytterligare *aesthetics* kan vara punkternas färger (`color`) och storlek (`size`).

```{r}
dat_small <- dat %>% filter(artist_name == "The Weeknd")

ggplot(dat_small, aes(tempo, danceability, size = valence, color = mode_name)) +
  geom_point()
```

## Import av data från en Excelfil

Inom vetenskapen är Excel, på gott och ont, det vanligaste filformatet för mindre datamängder. Till den här delen ska vi arbeta med data från *Gapminder*, en stiftelse som sprider information om socio-ekonomisk utveckling och global hälsa.

::: {.exercise name="Excelfil från Canvas"}
Hitta excelfilen *Gapminder.xlsx* på Canvas och ladda ner den. Hitta mappen som filen laddats ned till.
:::

I R kan man läsa in data från en Excel-fil med funktionen `read_excel()` från paketet `readxl`. Som argument till funktionen sätts filens sökväg - dess placering på hårddisken. Stycket nedan importerar från en excelfil som ligger på hårddisken *C:* i mappen *Downloads*, under *User_name*, under *Users*.

```{r, eval = T}
library(readxl) # Ladda readxl
```


```{r, eval = F}
gapminder <- read_excel("C:/Users/User_name/Downloads/Gapminder.xlsx")
gapminder
```

::: {.exercise name="Importera från excelfil"}
Vad är sökvägen för den nedladdade filen *Gapminder.xlsx*? Gör lämplig ändring i koden ovan för att läsa in data från den filen. Notera att R använder högerlutande snedstreck `/`, så om en kopierad sökväg har vänster-snedstreck måste de ändras. Kontrollera att datan blivit korrekt inläst genom att köra objektnamnet `gapminder`.
:::

En R-session har alltid en grundmapp, ett *Working directory*. Man kan se vilken mapp det är genom att köra

```{r, eval = F}
getwd()
```

En filsökväg kan anges antingen som en fullständig sökväg, som ovan, eller relativt *working directory*. Om man till exempel har en fil *Gapminder.xlsx* som ligger i en mapp *Data* som i sin tur ligger i *working directory*, kan man importera data från filen med

```{r}
gapminder <- read_excel("Data/Gapminder.xlsx")
gapminder
```

::: {.exercise name="Working directory"}
Identifiera *working directory* för din nuvarande Rs-session genom att köra `getwd()`.
:::

RStudio har också en inbyggd funktionalitet för att importera data. Man kan hitta den genom att gå till *Environment*-fliken och sedan *Import Dataset*. Det kan vara en bra hjälp, i synnerhet om man vill sätta datatyp för någon specifik kolumn.

Om du inte har tillgång till Canvas kan Gapminder-datan alternativt hämtas från paketet Gapminder.

```{r, eval = F}
# install.packages("gapminder")
library(gapminder)
gapminder
```

## Sammanfattande lägesmått

Den importerade datan ger medellivslängd, populationsstorlek och bnp per capita per land och år. Vi kan börja med att producera en bubbelgraf över datan - en av de presentationer Gapminder ofta använder. En bubbelgraf är ett spridningsdiagram där punktens storlek beror på en tredje variabel.

```{r}
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = continent)) +
  geom_point() +
  facet_wrap(~ year)
```

En interaktiv version kan vara bra om man vill identifiera någon punkt.

```{r}
g <- ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = continent, text = country)) +
  geom_point() +
  facet_wrap(~ year)

library(plotly)
ggplotly(g)
```

Under föreläsningen såg vi exempel på två lägesmått: medelvärdet (egentligen det *aritmetiska* medelvärdet) och medianen. De har bägge enkla funktioner i R: `mean()` respektive `median()`. Vi plockar ut en variabel ur datan och beräknar bägge.

```{r}
gdpPercap <- gapminder$gdpPercap
mean(gdpPercap)
median(gdpPercap)
```

Samma sak kan göras med en pipe `%>%` och `summarise()`.

```{r}
gapminder %>% 
  summarise(Mean = mean(gdpPercap),
            Median = median(gdpPercap))
```

::: {.exercise name="Lägesmått av livslängd"}
Gör lämpliga ändringar i exemplet ovan för att beräkna lägesmått för medellivslängd (`lifeExp`).
:::

Den andra lösningen, med en pipe och `summarise()`, kan enkelt utvecklas med ett `group_by()`-steg för att beräkna medel och median per någon grupp, t.ex. per år.

```{r}
gapminder %>% 
  group_by(year) %>% 
  summarise(Mean = mean(gdpPercap),
            Median = median(gdpPercap))
```

::: {.exercise name="Lägesmått per kontinent"}
Gör lämpliga ändringar i exemplet ovan för att beräkna lägesmått per kontinent. Vad måste läggas till för att också beräkna maximum och minimum per kontinent (funktionerna `max()` och `min()`)?
:::

::: {.exercise name="Upprepade mätningar"}
Finns det några problem med att beräkna medelvärde per kontinent på den här datan? (Jag kan se minst två.)
:::

I vetenskapliga publikationer redovisas medelvärden ofta med ett stapeldiagram. Som exempel ges staplar för medelvärdet av bnp per kontinent för 2007.

```{r}
dat_gdp_2007 <- gapminder %>% 
  filter(year == 2007) %>% 
  group_by(continent) %>% 
  summarise(Mean = mean(gdpPercap))

ggplot(dat_gdp_2007, aes(continent, Mean)) +
  geom_col()
```

För att få lite mer information kan man lägga till de individuella punkterna.

```{r}
ggplot(dat_gdp_2007, aes(continent, Mean)) +
  geom_col() +
  geom_point(aes(continent, gdpPercap), data = gapminder %>% filter(year == 2007))
```

Eftersom `geom_point()` här bygger på annan data än kolumnerna från `geom_col()` anger vi en ny `aes()`-funktionen och sätter argumentet `data`. Det kan också vara informativt att använda `geom_text()` för länderna. Etiketterna sätts med argumentet `label` i `aes()`. (Om man oroar sig för överlappande etiketter och letar efter lite överkurs kan man titta på paketet `ggrepel`.)

```{r, eval = F}
ggplot(dat_gdp_2007, aes(continent, Mean)) +
  geom_col() +
  geom_text(aes(continent, gdpPercap, label = country), data = gapminder %>% filter(year == 2007), size = 2)
```

::: {.exercise name="Graf för livslängd"}
Gör om stapeldiagrammet. Denna gång med livslängd (`lifeExp`) istället för bnp per capita (`gdpPercap`).
:::

## Sammanfattande spridningsmått

Under föreläsningarna såg vi några mått på spridning: varians, standardavvikelse och kvartilavstånd (IQR, *inter-quartile range*). De har alla motsvarande funktioner i R (`var()`, `sd()`, och `IQR()`) som kan användas på samma sätt som funktionerna för lägesmått.

```{r}
gdpPercap <- gapminder$gdpPercap

var(gdpPercap)
sd(gdpPercap)
IQR(gdpPercap)
```

Alternativt med en pipe och `summarise()`.

```{r}
gapminder %>% 
  summarise(Varians = var(gdpPercap),
            Standardavvikelse = sd(gdpPercap),
            Kvartilavstånd = IQR(gdpPercap))
```

Lösningen med pipe och `summarise()` kan som tidigare utvecklas med `group_by()`.

```{r}
gapminder %>% 
  group_by(year) %>% 
  summarise(Varians = var(gdpPercap),
            Standardavvikelse = sd(gdpPercap),
            Kvartilavstånd = IQR(gdpPercap))
```

::: {.exercise name="Graf för livslängd"}
Gör lämpliga ändringar i det sista exempel för att istället beräkna spridningsmått för livslängd.
:::

Vi avslutar med tre vanliga illustrationer av vetenskaplig data - ett linjediagram med felstaplar, ett stapeldiagram med felstaplar, och ett lådagram. För linjediagrammet beräknar vi medelvärdet och spridningsmått för bnp över år och kontinent. Som spridningsmått använder vi *medelfelet*, vilket beräknas som standardavvikelse delat på roten ur antalet observationer.

```{r}
dat_sum <- gapminder %>% 
  group_by(year, continent) %>% 
  summarise(Mean = mean(gdpPercap),
            SE = sd(gdpPercap) / sqrt(n()))
dat_sum
```

Med `ggplot2` kan vi bygga ett linjediagram med `geom_line()` och lägga till felstaplar med `geom_errorbar()`. Den senare behöver `aes()`-argument för `ymin` och `ymax` - nedre och övre del av felstapeln. Vi sätter dem till medelvärdet minus respektive plus ett medelfel.

```{r}
ggplot(dat_sum, aes(year, Mean, color = continent)) +
  geom_line() +
  geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE))
```

::: {.exercise name="Bredd"}
Felstaplarna från `geom_errorbar()` har väldigt breda ändar. Använd hjälpsidan för geomet `?geom_errorbar`, i synnerhet exemplen längst ned, och se om det går att ändra bredden.
:::

En graf med staplar och felstaplar kan konstrueras på ett likande sätt. Följande exempel visar staplar över livslängd per kontinent. Felstapeln ges av standardavvikelsen.

```{r}
dat_sum <- gapminder %>% 
  filter(year == 2007) %>% 
  group_by(continent) %>% 
  summarise(Mean = mean(lifeExp),
            SD = sd(lifeExp))
dat_sum
```

Vi bygger en ggplot med `geom_col()` och `geom_errorbar()`. Felstapels konstruktion kan anges i en notis med funktionen `labs()`.

```{r}
ggplot(dat_sum, aes(continent, Mean, fill = continent)) +
  geom_col()+
  geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD)) +
  labs(title = "Average life expectancy by continent, 2007",
       caption = "Errorbars given by mean +/- standard deviation.
       Source: Gapminder")
```

::: {.exercise name="Staplar för 1982"}
Gör lämpliga ändringar i exempel ovan för att konstruera ett stapeldiagram med felstaplar för året 1982 och variabeln gdpPercap.
:::

Ett lådagram anger fördelningen av en variabel genom att illustrera minimum, maximum och kvartiler. Kvartiler är mått som delar en datamängd i fyra lika stora delar (så att en fjärdedel ligger under första kvartilen, en fjärdedel mellan första och andra kvartil, och så vidare). Med `ggplot2` kan vi bygga ett lådagram med `geom_boxplot()`. Exempel ger en låda per år och kontinent.

```{r}
ggplot(gapminder, aes(year, lifeExp, fill = continent, group = year)) +
  geom_boxplot() +
  facet_wrap(~ continent)
```

::: {.exercise name="Group-argumentet"}
I lådagrammet används argumentet `group`. Vad gör det? Vad händer om man tar bort det?
:::

## Ordna upp beskrivande statistik och exportera

Efter att ha beräknat någon beskrivande statistik kan det vara bra att titta på hur resultaten kan snyggas upp och exporteras i något lämpligt format. Ta den tabell med medelvärden vi producerade i ett tidigare exempel.

```{r}
dat_sum <- gapminder %>% 
  filter(year == 2007) %>% 
  group_by(continent) %>% 
  summarise(Mean = mean(lifeExp),
            SD = sd(lifeExp))
dat_sum
```

Ett vanligt skrivsätt för medelvärde och standardavvikelse är som *m ± sd*. Vi kan använda funktionen `paste()` för att slå ihop kolumner till en sammanhängande text.

```{r}
dat_sum %>% 
  mutate(mean_plus_minus_sd = paste(Mean, "±", SD))
```

Vi måste avrunda medelvärdet och standardavvikelsen först. Det kan man göra med `round()`, vars argument är den variabel man vill avrunda och antalet decimaler man vill avrunda till.

```{r}
dat_sum <- dat_sum %>% 
  mutate(mean_plus_minus_sd = paste(round(Mean, 1), "±", round(SD, 1)))
```

::: {.exercise name="Tappade nollor"}
Utfallet ovan är nära men inte heller riktigt vad som behövs. I de fall där funktionen avrundat till en nolla har decimal tappats. Hur kan man visa en avslutande nolla? Följande tråd på StackOverflow besvarar samma fråga.

https://stackoverflow.com/questions/42105336/how-to-round-a-number-and-make-it-show-zeros

Försök använda kod därifrån för att lägga till en avslutande nolla.
:::

Objekt kan exporteras från R på liknande som det importeras - med särskilda exportfunktioner (*write*-funktioner) beroende på filtyp. För att exportera till en csv-fil man man anvnäda `write_csv()`. Ingående argument är det objekt man vill exportera och den fil man vill exportera till. R ger ingen varning om man skriver över en existerande fil, så var lite försiktiga här.

Precis som vid import använda R *working directory* om inget annat anges. Följande exporterar objektet `dat_sum` till en csv-fil *Exporterad data från R.csv* i *working directory*.

```{r, eval = F}
getwd()
write_csv(dat_sum, "Exporterad data från R.csv")
```

Därifrån skulle man kunna öppna filen i något kalkylprogram, snygga till layouten, och sedan klippa in i ett textdokument.

## Stegvis beräkning av varians

Det vara nyttigt att göra en stegvis beräkning av varians (och standardavvikelse) för att få en lite bättre förståelse av vad det faktiskt beskriver. Nedan ges en slumpmässig exempeldata med fem observationer. Om du har en tärning från datorövning 1 kan du med fördel kasta den nu, och ersätta värdena med dina egna utfall

```{r}
dat <- data.frame(Rad = c(1,2,3,4,5), x = c(6,3,2,3,5))
dat
```

En variansberäkning har följande steg,

1. beräkna medelvärdet,
2. beräkna utfallet minus medelvärdet för varje observation,
3. ta differenserna i kvadrat,
4. summera kvadraterna,
5. dela summan med antalet observationer minus ett.

Vi har tidigare sett beräkningen av medelvärden med `mean()`. En skillnad mot tidigare är att vi gör det i ett `mutate()` steg istället för `summarise()`, eftersom vi vill ha kvar den tidigare strukturen med flera rader.

```{r}
dat <- dat %>% 
  mutate(Medelvärde = mean(x))
dat
```

Därefter tar vi differensen mellan observationernas värden och medelvärdet.

```{r}
dat <- dat %>% 
  mutate(Differenser = x - Medelvärde)
dat
```

Därefter tar vi kvadrater av differenserna. För att ange en kvadrat används symbolen `^2`, t.ex. `3^2` för tre i kvadrat.

```{r}
dat <- dat %>% 
  mutate(Kvadrater = Differenser^2)
dat
```

Först i nästa steg summerar vi kvadraterna.

```{r}
dat_sum <- dat %>% 
  summarise(Kvadratsumma = sum(Kvadrater))
dat_sum
```

Som avslutande steg delar vi kvadratsumman med antalet observationer minus ett. För fem observationer delar vi alltså med fyra.

```{r}
dat_sum %>% mutate(Varians = Kvadratsumma / 4)
```

Vi kan se om vi fått rätt genom att beräkna variansen med funktionen `var()`.

```{r}
var(dat$x)  # Dollartecken för att ta ut kolumnen x i objektet dat
```

## Kumulativt medelvärde

Om man har data som av någon anledning samlas in i sekvens kan det vara intressant att beräkna och illustrera den med ett *kumulativt medelvärde*. En serie med kumulativa medelvärden beräknas genom att för varje nytt värde ta medelvärden av de värden man hittills samlat in - vid tio värden tar man medelvärdet av de tio, vid elva värden medelvärdet av de elva, och så vidare.

Med de tärningsvärden vi hade innan kan vi beräkna ett kumulativt medelvärde genom att först beräkna summan med `cumsum()` och sedan dela på antalet kast. För att förenkla beräkningen av antalen tar vi fram sekvensen med antal kast i ett `mutate()`-steg.

```{r}
dat_dice <- data.frame(Utfall = c(6,3,2,3,5)) %>% 
  mutate(Kast = 1:n())
dat_dice

dat_dice <- dat_dice %>% 
  mutate(`Kumulativ summa` = cumsum(Utfall),
         `Kumulativt medelvärde` = `Kumulativ summa` / Kast)
dat_dice
```

Om beräkning inte är uppenbar här, ta någon minut för att förstå den.

::: {.exercise name="Kumulativt medelvärde"}
Vad ska läggas till för att stycket nedan ska ge en linjegraf över medelvärdet?

```{r, eval = F}
ggplot(dat_dice, aes(x = Kast, y = ___)) +
  ___()
```
:::

::: {.exercise name="Fler tärningskast"}
Kasta din tärning ytterligare några gånger, gärna på en mjuk yta. Fyll i dina utfall och gör grafen från föregående uppgift. Kan man se en tendens för medelvärdet att minska i varians vid fler kast?

```{r, eval = F}
dat_dice <- data.frame(Utfall = c(___)) %>% 
  mutate(Kast = 1:n(),
         `Kumulativ summa` = cumsum(Utfall),
         `Kumulativt medelvärde` = `Kumulativ summa` / Kast)
dat_dice
```
:::

::: {.exercise name="Kumulativ frekvens"}
Om man vill titta på andelen gånger ett visst utfall inträffat talar man om *kumulativ frekvens* snarare än *kumulativt medelvärde*. Använd stycket nedan för att titta på andelen gånger utfallet varit en etta (ett *positivt* utfall, i begreppets kliniska mening). Om ett inte är ett möjligt utfall på din tärning, ändra ettan till något mer lämpligt.

```{r, eval = F}
dat_dice <- data.frame(Utfall = c(___)) %>% 
  mutate(Kast = 1:n(),
         `Positivt utfall` = Utfall == 1,
         `Kumulativt antal` = cumsum(`Positivt utfall`),
         `Kumulativ frekvens` = `Kumulativt antal` / Kast)
dat_dice

ggplot(dat_dice, aes(x = Kast, y = `Kumulativ frekvens`)) +
  geom_line()
```
:::

## Darwin-exempel

::: {.exercise name="Stapeldiagram med felstaplar"}
Darwins studie gav följande data:

```{r, echo = F}
dat <- readxl::read_excel("Data/Uppgiftsdata.xlsx", sheet = "Darwin")

dat %>% 
  mutate(ID = c(1:15,1:15)) %>% 
  pivot_wider(names_from = Metod, values_from = Utfall) %>% 
  select(-ID) %>% 
  kable()
```

Konstruera ett stapeldiagram med felstaplar där stapelns höjd ges av medelvärdet inom gruppen och felstapelns längd av standardavvikelsen inom gruppen.

Datan finns tillgänglig i arket *Darwin* i excelfilen *Uppgiftsdata.xlsx*. Exceldata kan läsas in med funktionen `read_excel` från paketet `readxl`.
:::

::: {.hypothesis name="Stapeldiagram med felstaplar"}
Felstaplar kan konstrueras genom att beräkna medelvärde och standardavvikelse, och sedan *pipa* (`%>%`) in i en plot där staplar konstrueras med `geom_bar` och felstaplar med `geom_errorbar`.

```{r}
dat <- readxl::read_excel("Data/Uppgiftsdata.xlsx", sheet = "Darwin")
dat %>% 
  group_by(Metod) %>% 
  summarise(m = mean(Utfall), s = sd(Utfall)) %>% 
  ggplot(aes(Metod, m)) +
  geom_bar(stat = "identity", width = 0.3, col = "black", fill = "white") +
  geom_errorbar(aes(ymin = m - s, ymax = m + s), width = 0.1) +
  labs(caption = "Felstapel anger +/- en standardavvikelse")
```

Det är inte alltid klart vilket spridningsmått felstaplarna illusterar (vanliga alternativ är standardavvikelsen, medelfelet (standardavvikelsen delat på roten ur stickprovsstorleken) och konfidensintervallet). Det är därför god praxis att skriva ut vad felstaplarna anger.
:::

## Bonus. Tredimensionella grafer med `plotly`

Förra gången anvnäde vi paketet `plotly` för att göra en interaktiv graf. Paketet har också funktioner för 3d-grafer. Börja med att ladda paketet.

```{r}
library(plotly)
```

Vi börjar med ett enkelt exempel på en 3d-graf med lite skapad data.

```{r, eval = F}
dat_ex <- data.frame(Var1 = c(1,2,3), Var2 = c(3,1,2), Var3 = c(2,3,1), Type = c("A", "B", "C"))
dat_ex

plot_ly(dat_ex, x = ~Var1, y = ~Var2, z = ~Var3, color = ~Type) %>% 
  add_markers()
```

Om grafen inte kommer upp direkt kan det fungera att trycka på den lilla ikonen med ett fönster och en pil i *Viewer*-fliken. Grafen ska då öppnas i en webbläsare.

Syntaxen till `plot_ly()` är inte helt olik `ggplot()`. Först anges datan, därefter argument för x- y-, och z-koordinater. Notera tilde-tecknet `~` före variabelnamnen. Eventuell färg sätts med `color`. Efter det lägger man till punkter (här *markers*) med en pipe in i `add_markers()`. Vi vill göra en liknande graf med gapminder-datan, men får börja med att filtrera på ett visst år.

::: {.exercise name="Filtrera för år"}
Vad måste läggas till i funktionen nedan för att filtrera för data där året är 2007?

```{r, eval = F}
dat_2007 <- gapminder %>% 
  ___(year == ___)
```
:::

Vi kan nu konstruera en 3d-graf med datan.

::: {.exercise name="Gapminder i 3d"}
Vad måste läggas till i funktionen nedan för en 3d-graf med befolkningsmängd (`pop`)  på x-axeln, livslängd (`lifeExp`) på y-axeln, bnp per capita (`gdpPercap`) på z-axeln, och färg efter kontinent (`continent`)? För att kunna identifiera specifika länder kan man också sätta argumentet `text`.

```{r, eval = F}
plot_ly(___, x = ~___, y = ~___, z = ~___, color = ~___, text = ~country) %>% 
  add_markers()
```
:::

::: {.exercise name="Log-transformationer"}
Inom statistiken är det vanligt att transformera variabler för att ta bort extremeffekter och visa på specifika dataegenskaper. En vanlig transform är att *logaritmera* ett värde, vilket innebär att man istället för att använda det ursprungliga värdet använder exponenten i någon bas (ofta basen tio). Ta till exempel värdet 10000, dess tio-logaritm är 4, eftersom 10 upphöjt i 4 är 10000. Logaritmer är vanliga vid data med extremvärden.

Grafen i uppgiften ovan präglas mycket av skillnader i bnp och befolkningsstorlek. Testa att tio-logaritmera variablerna och se om det blir en mer eller mindre överskådlig graf. Logaritmen kan göras genom att byta den ursprungliga variabeln mot en variabel transformerad med `log10()`. Fyll i stycket nedan.

```{r, eval = F}
plot_ly(___, x = ~log10(___), y = ~log10(___), z = ~___, color = ~___, text = ~country) %>% 
  add_markers()
```
:::

::: {.exercise name="Följa ett land"}
Likt en ggplot kan man lägga till graf-element. Här använder man dock en pipe för lägga till ett nytt element. Fyll i kodstycket nedan. Vad, om något, har lagts till i grafen?

```{r, eval = F}
plot_ly(___, x = ~log10(___), y = ~log10(___), z = ~___, color = ~___, text = ~country) %>% 
  add_markers() %>% 
  add_lines(data = gapminder %>% filter(country == "Costa Rica"))
```
:::

::: {.exercise name="Spotify 3d"}
Som avslutning återvänder vi till spotify-datan från datorövning 1. Fyll i stycket nedan för att skapa en graf med tempo, dansbarhet och valens (`tempo`, `danceability`, `valence`) på axlarna, storlek efter energi (`energy`) och text efter spårnamn (`track_name`). Filtrera på valfri artist. Använd `unique(dat_spot$artist_name)` för att se tillgängliga artister.

```{r, eval = F}
dat_spot <- read_csv("https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Spotify_data.csv")
dat_small <- dat_spot %>% filter(artist_name == "Weyes Blood")

plot_ly(dat_small, x = ~___, y = ~___, z = ~___, size = ~___, text = ~___) %>% 
  add_markers()
```
:::

## Valfria hemuppgifter

::: {.exercise name="TidyTuesday"}
*TidyTuesday* är ett R-kopplat pedagogiskt projekt som varje vecka publicerar ett nytt dataset och utmanar allmänheten att skapa bästa möjliga visualisering av data. Resultaten publiceras vanligen på Twitter med *#TidyTuesday*. På sidan
https://github.com/rfordatascience/tidytuesday/tree/master/data/2022
finns en tabell med dataset publicerade under 2022. Gå igenom listan, hitta ett intressant fall och läs informationen om det (genom att klicka på länken). Är det möjligt att förstå beskrivningen av datan?
:::

::: {.exercise name="r/dataisbeautiful"}
Gå till reddit-sidan *dataisbeautiful*. Välj en graf som verkar tydlig eller vacker eller intressant. Försök förstå den i termer av data (vilken information ligger bakom grafen), geometrier (vilka geometriska former är synliga i grafen, punkter, linjer, staplar), och estetik (vilka datavariabler styr hur geometrin ser ut och var den är placerad).
:::

::: {.exercise name="More or Less: Behind the Stats"}
BBC Radio har ett program om statistik, se https://www.bbc.co.uk/programmes/p02nrss1. Lyssna på ett avsnitt. Sammanfatta det i haiku-form.
:::

::: {.exercise name="gganimate"}
Med paketet `gganimate` (https://gganimate.com/) kan man göra animationer av ggplot-grafer. Installera paketet med `install.packages("gganimate")` och försök kör de exempel som ges på hemsidan.
:::

::: {.exercise name="Skumma ett paper"}
Hitta en *vetenskaplig* artikel i valfri tidskrift. Vilka läges- och spridningsmått kan du hitta? Vilka grafer?
:::

<!--chapter:end:Rmd/Datorövning-2.Rmd-->


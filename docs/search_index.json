[["index.html", "R-anvisningar till Grundläggande statistik Kapitel 1 Introduktion", " R-anvisningar till Grundläggande statistik 2022-07-27 Kapitel 1 Introduktion Detta dokument är en kort introduktion till R för en kurs i grundläggande statistik. "],["installation.html", "Kapitel 2 Installation 2.1 Inledning 2.2 Installation av R 2.3 Installation av RStudio 2.4 Gränssnittet i RStudio 2.5 Paket i R", " Kapitel 2 Installation 2.1 Inledning För att köra R-kod på sin dator krävs en installation av programspråket R. För att effektivt arbeta i R används ofta en utvecklingsmiljö (ett tilläggsprogram som på flera sätt förenklar arbetet) och här ges anvisningar till den vanligaste utvecklingsmiljön för R, som är RStudio. För att komma ingång måste man alltså installera R och RStudio. 2.2 Installation av R Programspråket R kan laddas ner från https://www.r-project.org/ med följande steg: Klicka på CRAN längst upp till vänster. Klicka på den översta länken under 0-Cloud. Välj en nedladdning beroende på operativsystem. För Windows, välj base. För macOS, välj den senaste tillgängliga versionen. Installera R från den nedladdade filen. Installation sker som för andra nedladdade program. 2.3 Installation av RStudio RStudio kan laddas ner från https://www.rstudio.com/ med följande steg: Klicka på Download uppe till höger. Scrolla nedåt och välj Download under RStudio Desktop. Klicka på nedladdningsknappen. Installera RStudio från den nedladdade filen. Installation sker som för andra nedladdade program. 2.4 Gränssnittet i RStudio När man nu öppnar RStudio ser man att fönstret är uppdelat i fyra delar och att varje del består av en eller flera flikar. De viktigaste är i nuläget Console där kod körs och resultat skrivs ut, Environment där man ser skapade objekt, History där man ser tidigare körd kod, Plots där man ser skapade grafer, och Help där man ser hjälpsidor för funktioner. Ofta skriver man inte sin kod direkt i konsollen, utan i ett separat skript - en vanlig textfil som innehåller den kod man vill köra. Genom att organisera sin kod i ett skript kan man lätt strukturera och dokumentera sitt arbete. I RStudio kan man öppna ett nytt skript genom att gå till File &gt; New File &gt; R Script eller genom att klicka Ctrl + Shift + N. Ett tomt skript öppnar sig då i det övre vänstra delfönstret. Om man skriver a &lt;- 5 i skriptet och trycker Ctrl + Enter bör man se att koden i skriptet körs i konsollen. Om man tittar i fliken Environment ska man också se att det nu skapats ett objekt a. 2.5 Paket i R En av de stora styrkorna med R är att språket kan byggas ut av dess användare. De här tilläggen kan sedan samlas i paket (packages) och delas med andra. Rs officiella bibliotek för paket kallas för CRAN (Comprehensive R Archive Network) och består av mer än 18 000 uppladdade paket som innehåller allt från fritt tillgänglig data till avancerade statistiska modeller. För att använda ett specifikt paket måste det först installeras. Om man vet namnet på paketet man vill installera kan man köra install.packages(&quot;tidyverse&quot;) I det här fallet installeras paketet tidyverse, vilket innehåller funktioner för hantering av data. I RStudio kan man också installera paket från Packages-fliken. Paket måste också laddas för varje ny session. Innan man kan använda innehållet i ett paket måste man därför köra library(tidyverse) "],["datorövning-1.-datahantering-och-grafer.html", "Kapitel 3 Datorövning 1. Datahantering och grafer 3.1 Uppstart och orientering 3.2 Packages från CRAN 3.3 Objekt och funktioner 3.4 Sekvenser av funktioner 3.5 Datainskrivning och dataimport från web 3.6 Transformera en tabell med select, filter, mutate och summarise 3.7 Grafer med ggplot2 3.8 Bonus: interaktiva grafer med plotly 3.9 Bonus: Warming stripes 3.10 Valfria hemuppgifter", " Kapitel 3 Datorövning 1. Datahantering och grafer Datorövning 1 handlar om grunderna till R. Efter övningen ska vi kunna Starta RStudio och orientera oss i gränssnittet, Installera och ladda tilläggspaket (Packages) Definera objekt och tillämpa funktioner i R, Importera data från en online-källa, Transformera en tabell med data genom att välja kolumner, filtrera rader och summera per grupp, Skapa grafer med ggplot2. 3.1 Uppstart och orientering För att arbeta i R måste vi installera språket R och ett gränssnitt för att arbeta i R, vanligen RStudio. Titta på kapitlet Installation om programmen inte är installerade på ditt system. Starta RStudio, till exempel genom att gå till Startmenyn och söka på RStudio eller genom att dubbelklicka på en fil som öppnas i RStudio. Gränssnittet i RStudio är uppdelat i fyra delar och varje del består av en eller flera flikar. De viktigaste är i nuläget Console där kod körs och resultat skrivs ut, Environment där man ser skapade objekt, History där man ser tidigare körd kod, Plots där man ser skapade grafer, och Help där man ser hjälpsidor för funktioner. Uppgift 3.1 (Help-fliken) Hitta fliken Help, klicka på husikonen under fliken. Finns det en länk med RStudio Cheat Sheets? Följ den länken för att hitta guider till R som kan bli nyttiga längre fram. För nu, gå tillbaka till RStudio. Ofta skriver man inte sin kod direkt i konsollen, utan i ett separat skript - en vanlig textfil som innehåller den kod man vill köra. Genom att organisera sin kod i ett skript kan man lätt strukturera och dokumentera sitt arbete. I RStudio kan man öppna ett nytt skript genom att gå till File &gt; New File &gt; R Script eller genom att klicka Ctrl + Shift + N. Ett tomt skript öppnar sig då i det övre vänstra delfönstret. Om du läser det här i RStudio, genom att ha laddat ner .R-filen, läster du just nu ett skript. Uppgift 3.2 (Ett första skript) Öppna ett nytt skript genom File-menyn eller genom Ctrl + Shift + N. Skriv a &lt;- 5 i skriptet och tryck Ctrl + Enter. Titta i flikarna Console och Environment. Har något hänt? Du bör se att koden i skriptet körts i konsollen och att ett nytt objekt a ligger i Environment. 3.2 Packages från CRAN En av de stora styrkorna med R är att språket kan byggas ut av dess användare. De här tilläggen kan sedan samlas i paket (packages) och delas med andra. Rs officiella bibliotek för paket kallas för CRAN (Comprehensive R Archive Network) och består av mer än 18 000 uppladdade paket som innehåller allt från fritt tillgänglig data till avancerade statistiska modeller. För att använda ett specifikt paket måste det först installeras. Om man vet namnet på paketet man vill installera kan man köra install.packages(&quot;tidyverse&quot;) I det här fallet installeras paketet tidyverse, vilket innehåller funktioner för hantering av data. I RStudio kan man också installera paket från Packages-fliken. Uppgift 3.3 (Installera tidyverse-paketet) Kör raden ovan för att installera tidyverse. Du kan antingen köra raden genom att skriva den i Console eller genom att skriva i ett skript och köra därifrån genom Ctrl + Enter. Uppgift 3.4 (Installera gapminder-paketet) Paketet gapminder innehåller lite intressant data vi kommer använda senare. Installera paketet gapminder genom att fylla i och köra raden nedan. install.packages(&quot;___&quot;) Paket måste också laddas för varje ny session. Innan man kan använda innehållet i ett paket måste man därför köra library(tidyverse) Uppgift 3.5 (Ladda gapminder-paketet) Ladda paketet gapminder genom att fylla i och köra raden nedan. library(___) Uppgift 3.6 (Paket som inte finns) Vad händer om man försöker installera ett paket som inte finns på CRAN ? Testa till exempel install.packages(&quot;ThisIsNotTheNameOfAnyPackage&quot;) och library(ThisIsNotTheNameOfAnyPackage) 3.3 Objekt och funktioner Ett objekt i R är en namngiven informationsmängd. Objekt kan se ut på många olika sätt - under kursens gång används objekt som består av insamlad data (konstruerade som vektorer eller tabeller), objekt som är statistiska modeller, och flera andra former. I R skapar man objekt med assign-pilen &lt;- (mindre än och bindestreck). I ett tidigare exempel fanns raden a &lt;- 5 Här skapas ett objekt med namnet a som innehåller informationen 5. Assign-pilen pekar alltså på det namn man vill ge objektet och pekar från objektets innehåll. Ett lite mer komplicerat exempel på ett objekt ges av b &lt;- c(3, 1, 4, 1, 5, 9) Här skapas ett objekt b som innehåller en serie numeriska värden (en vektor). Uppgift 3.7 (Skapa en vektor) Skapa ett objekt med namnet new_vector som innehåller värden 5, 7 och 10 genom att fylla i följande rad. new_vector &lt;- c(_, _, _) Objekt kan manipuleras genom att tillämpa funktioner. En funktion tar någon ingående data och ger något utgående resultat. Funktioner anges genom att skriva funktionens namn följt av ingående data inom parenteser, och resultatet kan antingen skrivas ut i konsollen eller sparas som ett nytt objekt. En grundinstallation av R innehåller en mängd färdiga funktioner, t.ex. sum(b) ## [1] 23 vilket ger summan av värdena i vektorn b, plot(b) som ger en simpel graf, och sqrt(b) ## [1] 1.732051 1.000000 2.000000 1.000000 2.236068 3.000000 som beräknar kvadratroten för varje element i vektorn. Uppgift 3.8 (Summera vektorn) Fyll i och kör följande rad för att beräkna summan av vektorn new_vector sum(___) Vid konstruktionen av vektorn användes också en grundläggande funktion - funktionen c som tar en serie värden och skapar en sammanhängande vektor av värden. Alla R-funktioner har en tillhörande hjälpfil som kan plockas fram genom att skriva frågetecken följt av funktionsnamnet, t.ex. ?sum. Från hjälpfilen får man att sum tar numeriska vektorer som ingående värde och beräknar summan. Man kan styra funktionens beteende genom att sätta ett argument na.rm (vilket här styr hur funktionen hanterar saknade värden). Som illustration kan man titta på b &lt;- c(3, 1, 4, 1, 5, 9, NA) # Lägger till ett saknat värde sum(b) # na.rm = FALSE är grundinställning ## [1] NA sum(b, na.rm = TRUE) # na.rm sätts till TRUE ## [1] 23 Det första försöket sum(b) ger utfallet NA, men om man sätter na.rm = TRUE beräknas summan efter att det saknade värdet plockats bort. Notera också att skript kan kommenteras med #. 3.4 Sekvenser av funktioner Ofta vill man genomföra flera operationer på ett objekt. Man behöver då genomföra en sekvens av funktioner. Säg till exempel att man har värdena \\[(-4, -2, -1, 1, 2, 4)\\] och vill ta absolutvärde (vilket gör negativa tal till motsvarande positiva tal) och sedan summera. Den typen av sekvenser kan genomföras på ett par olika sätt. Ett första sätt är att spara resultatet i varje steg och sedan använda utfallet i nästa steg: c &lt;- c(-4, -2, -1, 1, 2, 4) c_absolute &lt;- abs(c) sum(c_absolute) ## [1] 14 Här skapas ett objekt c som innehåller en vektor där några tal är negativa. I nästa rad används abs för att skapa absolutvärden. Slutligen summeras absolutvärdena med sum. Notera att det är möjligt att skapa ett objekt med namnet c trots att det redan är namnet på en funktion - R förstår ur sammanhanget om objektet eller funktionen ska användas. Uppgift 3.9 (Kvadrat, summa och roten ur) Fyll i och kör följande rader för att ta varje värde i new_vector i kvadrat, sedan summera, och sedan ta roten ur. new_vector_squared &lt;- new_vector^2 # Ta kvadraten av varje värde new_vector_squared_sum &lt;- sum(___) # Summera vektorn med kvadrater sqrt(___) # Ta kvadratroten ur summan Ett alternativ är att skriva en senare funktion runt en tidigare funktion. Det fungerar för att R utvärderar funktioner inifrån-ut. Med samma exempel som tidigare får man sum(abs(c(-4, -2, -1, 1, 2, 4))) medan beräkningen i övningen blir sqrt(sum(new_vector^2)) Den här typen av skrivning kan spara plats men blir snabbt svårläst. Ett sista alternativ är att använda en så kallad pipe (namnet kommer från att en sekvens funktioner kallas en pipeline). En pipe skrivs %&gt;% och tar utfallet av en funktion till vänster och sänder till en funktion till höger. Språkligt kan pipen utläsas och sen. Funktionen kan laddas genom att ladda paketet tidyverse. Med samma exempel som tidigare kan vi skriva library(tidyverse) c(-4, -2, -1, 1, 2, 4) %&gt;% # Skapa en datamängd och sen abs() %&gt;% # ta absolutvärden, och sen sum() # beräkna summan. ## [1] 14 Uppgift 3.10 (Kvadrat, summa och rot med pipe) Fyll i de saknade funktionerna och kör följande rader för att ta varje värde i new_vector i kvadrat, sedan summera, och sedan ta roten ur, denna gång genom att länka funktionerna med en pipe %&gt;%. new_vector^2 %&gt;% # Ta kvadraterna av new_vector, och sen ___() %&gt;% # beräkna summan, och sen ____() # Ta kvadratroten (med sqrt()) 3.5 Datainskrivning och dataimport från web 3.5.1 Inskrivning av data Det första praktiska steget i en statistisk analys är att importera data. I R kan det göras genom att direkt skriva in sin data och spara som ett nytt objekt, men ett bättre och vanligare sätt är att importera sin data från en extern fil eller databas. I ett tidigare exempel användes funktionen c för att skapa en vektor av data. Ofta ordnas flera vektorer i en tabell där varje kolumn är en vektor och varje rad en observation av någon enhet. En datatabell (en data.frame i R) skapas genom funktionen data.frame() följt av namngivna vektorer. Exempeldata kan skrivas in genom föjande. dat &lt;- data.frame(Vecka = c(7,7,7,7,7,7,11,11,11,11,11,11), Behandling = c(&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;), Vikt = c(232,161,148,368,218,257,1633,2213,972,2560,2430,855), N = c(2.63,2.90,2.99,3.54,3.30,2.85,1.53,1.90,NA,2.58,NA,NA)) dat ## Vecka Behandling Vikt N ## 1 7 A 232 2.63 ## 2 7 A 161 2.90 ## 3 7 A 148 2.99 ## 4 7 B 368 3.54 ## 5 7 B 218 3.30 ## 6 7 B 257 2.85 ## 7 11 A 1633 1.53 ## 8 11 A 2213 1.90 ## 9 11 A 972 NA ## 10 11 B 2560 2.58 ## 11 11 B 2430 NA ## 12 11 B 855 NA Radbrytningar och blanksteg är oviktiga i R, och används bara för läsbarhet här. Saknade värden skrivs in som NA för not available. Notera att alla kolumner inte behöver vara av samma datatyp men att värden inom en kolumn måste vara det. Här är Behandling text medan övriga kolumner är numeriska. Uppgift 3.11 (Alea iacta est) Kasta din tärning tio gånger och skriv in resultatet i en datatabell i R med hjälp av grundkoden nedan. Om du saknar en tärning, fråga lämplig person om du kan få en. Behåll tärningen, den behövs till nästa datorövning (och närhelst man står inför ett avgörande livsbeslut). dat_dice &lt;- data.frame(Kast = c(1,2,3,4,5,6,7,8,9,10), Utfall = c(_,_,_,_,_,_,_,_,_,_)) dat_dice 3.5.2 Import från en extern fil Inskrivning av värden är ofta tidskrävande och kan lätt leda till misstag. Det är därför mycket vanligare att data läses in från en extern fil. Det finns en mängd funktioner för dataimport och det exakta valet av funktion beror på vilken typ av fil datan är sparad i. Ett vanligt filformat är .csv (comma separated values). Här importerar vi en fil med data från Spotify. dat &lt;- read_csv(&quot;https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Spotify_data.csv&quot;) dat ## # A tibble: 76,622 × 24 ## artist_name album_name track_number track_name album_type album_release_d… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 100 gecs 1000 gecs an… 1 money mac… album 2020-07-10 ## 2 100 gecs 1000 gecs an… 2 ringtone … album 2020-07-10 ## 3 100 gecs 1000 gecs an… 3 745 stick… album 2020-07-10 ## 4 100 gecs 1000 gecs an… 4 gec 2 Ü (… album 2020-07-10 ## 5 100 gecs 1000 gecs an… 5 hand crus… album 2020-07-10 ## 6 100 gecs 1000 gecs an… 6 800db clo… album 2020-07-10 ## 7 100 gecs 1000 gecs an… 7 stupid ho… album 2020-07-10 ## 8 100 gecs 1000 gecs an… 8 ringtone … album 2020-07-10 ## 9 100 gecs 1000 gecs an… 9 xXXi_wud_… album 2020-07-10 ## 10 100 gecs 1000 gecs an… 10 745 stick… album 2020-07-10 ## # … with 76,612 more rows, and 18 more variables: album_release_year &lt;dbl&gt;, ## # danceability &lt;dbl&gt;, energy &lt;dbl&gt;, key &lt;dbl&gt;, loudness &lt;dbl&gt;, mode &lt;dbl&gt;, ## # speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, ## # liveness &lt;dbl&gt;, valence &lt;dbl&gt;, tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, ## # explicit &lt;lgl&gt;, type &lt;chr&gt;, key_name &lt;chr&gt;, mode_name &lt;chr&gt;, key_mode &lt;chr&gt; Om importen fungerat kan man skriva ut tabellens översta rader genom att köra objektets namn. För att snabbt se vilka artister datan täcker kan man köra unique(dat$artist_name) där unique är en funktion som tar bort alla dubletter och dat$artist_name används för att plocka ut kolumnen artist_name ur tabellen dat. 3.6 Transformera en tabell med select, filter, mutate och summarise 3.6.1 Urval med select och filter En vanlig operation på en tabell är att göra ett urval - antingen ett urval av rader (t.ex. en viss artist), vilket kallas filtrering eller ett urval av variabler (t.ex. artist och albumnamn), vilket kallas selektion. Det finns flera olika sätt att göra ett urval i R. Det traditionella sättet är att använda index inom hakparenteser (t.ex. dat[4, 2] för fjärde raden, andra kolumnen) eller dollartecken för specifika kolumner (t.ex. dat$artist_name för artistnamn). Här fokuseras dock på hur det kan göras med funktionerna filter och select från paketet tidyverse. För att filtrera på ett givet land kan använda pipe-funktionen från datan till en filter-funktion, t.ex. dat %&gt;% # Ta spotify-datan och sen filter(artist_name == &quot;Robyn&quot;) # filtrera för en specifik artist ## # A tibble: 1,142 × 24 ## artist_name album_name track_number track_name album_type album_release_d… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Robyn Honey 1 Missing U album 2018-10-26 ## 2 Robyn Honey 2 Human Being album 2018-10-26 ## 3 Robyn Honey 3 Because It&#39;s… album 2018-10-26 ## 4 Robyn Honey 4 Baby Forgive… album 2018-10-26 ## 5 Robyn Honey 5 Send To Robi… album 2018-10-26 ## 6 Robyn Honey 6 Honey album 2018-10-26 ## 7 Robyn Honey 7 Between The … album 2018-10-26 ## 8 Robyn Honey 8 Beach2k20 album 2018-10-26 ## 9 Robyn Honey 9 Ever Again album 2018-10-26 ## 10 Robyn Honey 1 Missing U album 2018-10-26 ## # … with 1,132 more rows, and 18 more variables: album_release_year &lt;dbl&gt;, ## # danceability &lt;dbl&gt;, energy &lt;dbl&gt;, key &lt;dbl&gt;, loudness &lt;dbl&gt;, mode &lt;dbl&gt;, ## # speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, ## # liveness &lt;dbl&gt;, valence &lt;dbl&gt;, tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, ## # explicit &lt;lgl&gt;, type &lt;chr&gt;, key_name &lt;chr&gt;, mode_name &lt;chr&gt;, key_mode &lt;chr&gt; Inom filter-funktionen anges ett logisk villkor country == \"Sweden\" och utfallet är de rader där villkoret är sant. Notera de dubbla likhetstecknen - de måste användas för ett logisk villkor eftersom enkelt likhetstecken används för att skapa objekt och sätta funktionsargument. Uppgift 3.12 (Filtrera för artist) Vad måste ändras i koden för att istället plocka ut rader där artisten är Esperanza Spalding? Hur många rader har det urvalet? dat %&gt;% # Ta spotify-datan och sen filter(artist_name == &quot;Robyn&quot;) # filtrera för en specifik artist Om man vill välja flera artister kan man använda funktionen %in% på ett liknande sätt. dat %&gt;% filter(artist_name %in% c(&quot;Robyn&quot;, &quot;Esperanza Spalding&quot;)) och om man vill ha mer än ett villkor kan man rada dem i filter-funktionen eller ha flera filter-steg: dat %&gt;% filter(artist_name %in% c(&quot;Robyn&quot;, &quot;Esperanza Spalding&quot;), key_name == &quot;D#&quot;) alternativt dat %&gt;% filter(artist_name %in% c(&quot;Robyn&quot;, &quot;Esperanza Spalding&quot;)) %&gt;% filter(key_name == &quot;D#&quot;) För att se fler eller färre rader kan man använda en pipe %&gt;% till funktionen print. Följande skriver ut fem rader dat %&gt;% filter(artist_name %in% c(&quot;Robyn&quot;, &quot;Esperanza Spalding&quot;)) %&gt;% filter(key_name == &quot;D#&quot;) %&gt;% print(n = 5) ## # A tibble: 21 × 24 ## artist_name album_name track_number track_name album_type album_release_d… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Esperanza Spal… SONGWRIGH… 7 Formwela 7 album 2021-09-24 ## 2 Esperanza Spal… 12 Little… 2 To Tide U… album 2019-05-10 ## 3 Esperanza Spal… 12 Little… 3 &#39;Til the … album 2019-05-10 ## 4 Esperanza Spal… Emily’s D… 7 Ebony And… album 2016-01-01 ## 5 Esperanza Spal… Emily’s D… 7 Ebony And… album 2016-01-01 ## # … with 16 more rows, and 18 more variables: album_release_year &lt;dbl&gt;, ## # danceability &lt;dbl&gt;, energy &lt;dbl&gt;, key &lt;dbl&gt;, loudness &lt;dbl&gt;, mode &lt;dbl&gt;, ## # speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, ## # liveness &lt;dbl&gt;, valence &lt;dbl&gt;, tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, ## # explicit &lt;lgl&gt;, type &lt;chr&gt;, key_name &lt;chr&gt;, mode_name &lt;chr&gt;, key_mode &lt;chr&gt; Om man istället vill göra ett urval av kolumner kan man använda select. Som argument anges de kolumner man vill välja, t.ex. dat %&gt;% select(artist_name, album_name) ## # A tibble: 76,622 × 2 ## artist_name album_name ## &lt;chr&gt; &lt;chr&gt; ## 1 100 gecs 1000 gecs and The Tree of Clues ## 2 100 gecs 1000 gecs and The Tree of Clues ## 3 100 gecs 1000 gecs and The Tree of Clues ## 4 100 gecs 1000 gecs and The Tree of Clues ## 5 100 gecs 1000 gecs and The Tree of Clues ## 6 100 gecs 1000 gecs and The Tree of Clues ## 7 100 gecs 1000 gecs and The Tree of Clues ## 8 100 gecs 1000 gecs and The Tree of Clues ## 9 100 gecs 1000 gecs and The Tree of Clues ## 10 100 gecs 1000 gecs and The Tree of Clues ## # … with 76,612 more rows Som avslutning ges ett lite mer komplicerat exempel på ett urval av artist, år och spår för spår med ett tempo över 180 bpm släppta under 2015. dat %&gt;% # Ta datan och sen filter(album_release_year == 2015, # filtrera för rader där år är 2015, och tempo &gt; 180) %&gt;% # tempot över 160, och sen select(artist_name, album_release_year, track_name) # selektera på artist, år och spår ## # A tibble: 122 × 3 ## artist_name album_release_year track_name ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 A Sunny Day In Glasgow 2015 The Strange Presents of Idols (Mer… ## 2 A$AP Rocky 2015 Lord Pretty Flacko Jodye 2 (LPFJ2) ## 3 A$AP Rocky 2015 Lord Pretty Flacko Jodye 2 (LPFJ2) ## 4 Anderson .Paak 2015 Off the Ground ## 5 Björk 2015 Notget - Live ## 6 Björk 2015 Notget ## 7 Björk 2015 Notget ## 8 Björk 2015 Notget ## 9 Blood Orange 2015 Sandra’s Smile ## 10 Burna Boy 2015 Soke ## # … with 112 more rows Uppgift 3.13 (Snabba spår) Funktionen arrange sorterar data efter en angiven kolumn. Följande stycke ger oss Björks snabbaste spår. dat %&gt;% # Ta datan, och sen filter(artist_name == &quot;Björk&quot;) %&gt;% # filtrera för rader där artist är Björk, och sen select(artist_name, album_name, track_name, tempo) %&gt;% # välj kolumner med artist, album, spår och tempo, och sen arrange(-tempo) # ordna efter tempo (minus för fallande ordning) Gör lämpliga ändringar för att hitta Kate Bushs snabbaste spår. Gör ytterligare ändringar för att hitta Daft Punks långsammaste spår. 3.6.2 Ändra och skapa nya kolumner med mutate Variabler kan omräknas och nya variabler kan skapas med mutate-funktionen. I spotify-datan finns tempo som slag per minut. Om man vill ha slag per sekund kan man skapa en nya kolumn och beräkna den som tempo delat på 60. dat &lt;- dat %&gt;% mutate(beats_per_second = tempo / 60) Den inledande delen med dat &lt;- gör så att utfallet av beräkningen sparas i objektet dat. Vi kan skriva ut objektet och se resultatet av beräkningen: dat %&gt;% select(tempo, beats_per_second) ## # A tibble: 76,622 × 2 ## tempo beats_per_second ## &lt;dbl&gt; &lt;dbl&gt; ## 1 132. 2.20 ## 2 107. 1.78 ## 3 128. 2.14 ## 4 113. 1.89 ## 5 174. 2.89 ## 6 142. 2.36 ## 7 166. 2.77 ## 8 125. 2.08 ## 9 170. 2.83 ## 10 150. 2.50 ## # … with 76,612 more rows Uppgift 3.14 (Glädje per dansbarhet) Följande stycke beräknar kvoten av kolumnerna valence och danceability i en ny kolumn `valence_to_danceability. dat %&gt;% # Ta datan, och sen mutate(valence_to_danceability = valence / danceability) %&gt;% # beräkna valence delat på danceability, och sen select(valence, danceability, valence_to_danceability) # välj relevanta kolumner. Gör lämpliga ändringar för att multiplicera tempo och time signature. Ett passande namn för den nya kolumnen kan vara tempo_times_time_signature. I exemplet och uppgiften ovan skapades nya kolumn namn med understreck _ istället för mellanrum. Om man vill ha mellanrum i sina kolumnnamn måste man skriva namnet inom backticks ``` för att ange att namnet ska tolkas som en enhet. dat %&gt;% mutate(`Valence to danceability` = valence / danceability) %&gt;% # Namnet Valence to danceability skrivs inom backticks select(artist_name, `Valence to danceability`) ## # A tibble: 76,622 × 2 ## artist_name `Valence to danceability` ## &lt;chr&gt; &lt;dbl&gt; ## 1 100 gecs 1.81 ## 2 100 gecs 0.726 ## 3 100 gecs 0.683 ## 4 100 gecs 0.954 ## 5 100 gecs 1.15 ## 6 100 gecs 1.12 ## 7 100 gecs 0.921 ## 8 100 gecs 0.791 ## 9 100 gecs 1.01 ## 10 100 gecs 1.02 ## # … with 76,612 more rows 3.6.3 Summera kolumner med group_by och summarise För att presentera insamlad data på ett tolkningsbart sätt används sammanfattande mått såsom summor, medelvärden, medianer och standardavvikelser. Den typen av beräkningar kan göras som ett nytt steg i en pipe med hjälp av funktionen summarise. Om man kombinerar summarise med funktionen group_by kan man dessutom summera efter en indelning given av en annan variabel. En beräkning av genomsnittligt tempo per år kan till exempel ges av dat %&gt;% # Ta datan, och sen group_by(album_release_year) %&gt;% # gruppera efter år, och sen summarise(Medeltempo = mean(tempo)) # beräkna medelvärde av tempo ## # A tibble: 63 × 2 ## album_release_year Medeltempo ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1960 103. ## 2 1961 104. ## 3 1962 121. ## 4 1963 116. ## 5 1964 122. ## 6 1965 114. ## 7 1966 121. ## 8 1967 118. ## 9 1968 95.0 ## 10 1969 116. ## # … with 53 more rows I det sista steget skapas en variabel Medeltempo som ges av medelvärde av den ursprungliga variabeln tempo. Här använder vi också funktionen mean för att beräkna medelvärdet. Om man vill summera flera variabler kan man ange flera beräkning inom summarise, t.ex. dat %&gt;% # Ta datan, och sen group_by(album_release_year) %&gt;% # gruppera efter år, och sen summarise(Medeltempo = mean(tempo), # beräkna medelvärde av tempo Medelvalence = mean(valence), # beräkna medelvärde av valence antal_spår = n()) %&gt;% # beräkna antalet spår, och sen arrange(-Medelvalence) # ordna efter medelvalence i sjunkande ordning ## # A tibble: 63 × 4 ## album_release_year Medeltempo Medelvalence antal_spår ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1960 103. 0.816 29 ## 2 1961 104. 0.752 12 ## 3 1968 95.0 0.738 21 ## 4 1981 123. 0.671 17 ## 5 1965 114. 0.642 147 ## 6 1972 118. 0.641 64 ## 7 1976 123. 0.626 65 ## 8 1982 114. 0.624 50 ## 9 1975 123. 0.622 84 ## 10 1962 121. 0.613 13 ## # … with 53 more rows Uppgift 3.15 (Gladast artist) Vad ska ändras i stycket ovan för att beräkna medelvalence per artist istället för per år? Funktionen count() ger antalet rader uppdelat efter valfri kolumn. Den kan användas som en kortform för group_by() och summarise(). Vad måste ändras i stycket nedan för att se vilka artister som påverkar värdet för 1960? dat %&gt;% # Ta data, och sen filter(album_release_year == 1976) %&gt;% # ta ut rader där år är 1976, och sen count(artist_name, album_name, album_release_year) # räkna antalet rader per artist, album och år 3.7 Grafer med ggplot2 Vi kan nu börja titta på grafer. Eftersom datan är ganska stor och grafer lätt blir oöversiktliga, börjar vi med att skapa en lite mindre datamängd. dat_small &lt;- dat %&gt;% filter(artist_name == &quot;Robyn&quot;, album_type == &quot;album&quot;) Uppgift 3.16 (Valfritt artistbyte) Om du vill titta data på något annan artist, gör lämplig ändring i stycket ovan. Kom ihåg att man skriva ut artister i datan med unique(dat$artist_name). R har en mängd grundläggande funktioner för grafer. Ett enkelt spridningsdiagram kan till exempel skapas med plot(x = dat_small$tempo, y = dat_small$danceability) Tecknet $ används här för att välja en kolumn i en tabell. För mer avancerade grafer används dock ofta funktioner ur Rs paketbibliotek. Här illustreras det mest populära - ggplot2. I ggplot2 byggs grafer upp med tre grundläggande byggstenar: data, informationen man vill visualisera, aestethics, en koppling mellan data och visuella element såsom grafens axlar, objekts storlek och färg, geometries, de geometriska former som visas i grafen. En graf skrivs med en startfunktion ggplot som anger namnet på datan och grafens aestethics, och därefter sätts geometriska element genom funktioner som börjar med geom_. Ett spridningsdiagram kan t.ex. skapas med geom_point. ggplot(dat_small, aes(x = tempo, y = danceability)) + geom_point() Grafen kan byggas ut genom att sätta aestethics för färg och storlek. Man kan också dela en graf i småfönster med facet_wrap och styra grafens utseende genom att sätta ett tema såsom theme_bw. ggplot(dat_small, aes(x = tempo, y = danceability, color = mode_name)) + geom_point() + facet_wrap(~ album_name) Uppgift 3.17 (Dur och moll) Vad ska ändras i stycket nedan för att skapa en graf med dur/moll (mode_name) på x-axeln, valens (valence) på y-axeln och skilda småfönster för olika år (album_release_year)? ggplot(dat_small, aes(x = mode_name, y = valence, color = album_name)) + geom_point() + facet_wrap(~ album_release_year) Har spår i dur (major) högre valens? Andra graftyper kan skapas med andra geom_-funktioner. För ett linjediagram används geom_line. De observationer som ska ge en specifik linje anges med group i aes-funktionen. Låt oss beräkna medeldansbarhet över tid, uppdelat efter markeringen för explicit (alltså om spåret är barnvänligt eller inte). Exemplet visar också hur man använda flera geometrier genom att lägga till dem efter varandra med +. dat_mean_over_time &lt;- dat %&gt;% group_by(album_release_year, explicit) %&gt;% summarise(Mean_danceability = mean(danceability)) ggplot(dat_mean_over_time, aes(x = album_release_year, y = Mean_danceability, color = explicit)) + geom_line() + geom_point() Här ger färgen uppdelningen i explicit och icke-explicit (TRUE för explicit). Det finns också spår som saknat värde för explicit och därför blir NA här. Kan vi utifrån grafen säga att barnvänlig musik är mer eller mindre dansbar än icke-barnvänlig? Uppgift 3.18 (Explicit glädje) Vad ska ändras i stycket ovan för att för en graf över medelvalens (valence) istället för dansbarhet? Är barnvänlig musik gladare eller ledsnare är icke-barnvänlig? Stapeldiagram ges av geom_col (col för column). Man kan också använda geom_bar om man bara vill räkna antal rader per någon kategori. Följande beräknar valens per artist, ordnar efter valens, väljer ut de tjugo högsta, och plottar i ett (liggande) stapeldiagram. dat %&gt;% # Ta datan, och sen group_by(artist_name) %&gt;% # gruppera efter artist, och sen summarise(Mean_valence = mean(valence)) %&gt;% # ta medelvärdet av valence, och sen arrange(-Mean_valence) %&gt;% # ordna efter medelvalens (minustecken för sjunkande ordning), och sen slice(1:20) %&gt;% # ta ut de tjugo första raderna ggplot(aes(x = Mean_valence, y = artist_name, fill = Mean_valence)) + # starta en ggplot där x-axeln ges av valens och y-axeln av artist, och sen geom_col(color = &quot;black&quot;) # skapa en geometri av kolumner Argumentet fill styr färgen för ytor (här staplarnas ytor) medan color i geom_col() styr kanten runt varje stapel. Man kan styra grafiken i en ggplot genom funktionen theme(). Det är ett ganska komplicerat ämne, men låt oss titta på några grunder. Vi börjar med att skapa en enkel graf: en boxplot över dansbarhet per album för bandet Beach House. dat_small &lt;- dat %&gt;% filter(artist_name == &quot;Beach House&quot;, album_type == &quot;album&quot;) ggplot(dat_small, aes(danceability, album_name)) + geom_boxplot() Vi kan ändra utseendet på grafen genom argument inom geometrier och med funktionen theme(). I theme() sätter man de specifika egenskaper man vill ändra genom att tillskriva dem ett element. Valet av element beror på typen av grafiskt objekt - text sätts t.ex. med element_text() och ytor med element_rect() (för rectangle). Vi ger ett exempel med ändrad bakgrund, rutmönster, och teckenstorlek. ggplot(dat_small, aes(danceability, album_name)) + geom_boxplot(fill = &quot;lightblue&quot;) + theme(panel.background = element_rect(fill = &quot;red3&quot;), text = element_text(size = 15, color = &quot;white&quot;, family = &quot;serif&quot;), axis.text = element_text(color = &quot;white&quot;), plot.background = element_rect(fill = &quot;grey30&quot;, color = &quot;black&quot;), panel.grid.major.y = element_blank()) Uppgift 3.19 (Temaval 1) Ändra färgvalen i grafen ovan för att skapa snyggast möjliga graf. Funktionen colors() ger de färger som finns tillängliga i R. Man kan också använda hex-koden för färger, t.ex. fill = \"#ffdd00\". Uppgift 3.20 (Temaval 2) Ändra färgvalen i grafen ovan för att skapa fulast möjliga graf. Visa de två graferna för någon annan och se om de kan säga vilken som är vilken. 3.8 Bonus: interaktiva grafer med plotly Låt oss ta en titt på plotly, ett av flera R-paket som gör det möjligt att skapa interaktiva grafer. Vi börjar med att installera och ladda paketet. # install.packages(&quot;plotly&quot;) library(plotly) Paketet innehåller en smidig funktion ggplotly() för att göra en interaktiv graf från en ggplot. Vi börjar med att filtrera datan för en specifik artist och albumtyp. I samma pipe skapar vi en ny kolumn decade, som beräknar årtiondet utifrån året. Den exakta beräkning är inte så viktig, men ta gärna en titt och se om du förstår vad som delarna gör. dat_small &lt;- dat %&gt;% filter(artist_name == &quot;David Bowie&quot;, album_type == &quot;album&quot;) %&gt;% mutate(Decade = floor(album_release_year / 10) * 10) (Säg t.ex. att vi har året 1979. Att dela med 10 ger 197.9. Funktionen floor avrundar nedåt till 197. Multiplikationen med 10 ger 1970.) Vi kan nu konstruera en graf med ggplot(). Låt oss ha dansbarhet på x-axeln och valens på y-axeln. Geomet geom_point() ger ett spridningdiagram och facet_wrap(~ Decade) delar i småfönster efter årtionde. Slutligen tar theme(legend.position = \"none\") bort legenden - guiden som anger vilken färg som är vilket album. Notera att vi sparar grafen som ett objekt g. För att se grafen kör vi objektnamnet. g &lt;- ggplot(dat_small, aes(danceability, valence, color = album_name, text = track_name)) + geom_point() + facet_wrap(~ Decade) + # Skapar småfönster per årtionde theme(legend.position = &quot;none&quot;) # Tar bort legenden (kopplingen mellan färg och album) g När vi har en färdig ggplot kan ggplotly() ge en interaktiv version av samma graf. ggplotly(g) Uppgift 3.21 (Interaktiv graf med annan artist) Gör lämpliga ändringar i stycket nedan för att skapa en interaktiv graf med en annan artist och med tempo på x-axeln och dansbarhet på y-axeln. Kom ihåg att du kan se tillgängliga artister med raden unique(dat$artist_name). dat_small &lt;- dat %&gt;% filter(artist_name == &quot;David Bowie&quot;, album_type == &quot;album&quot;) %&gt;% mutate(Decade = floor(album_release_year / 10) * 10) g &lt;- ggplot(dat_small, aes(danceability, valence, color = album_name, text = track_name)) + geom_point() + facet_wrap(~ Decade) + # Skapar småfönster per årtionde theme(legend.position = &quot;none&quot;) # Tar bort legenden (kopplingen mellan färg och album) g ggplotly(g) Uppgift 3.22 (Interaktiv graf med andra axlar) Vi fortsätter med ett nytt exempel, nu med ett spridningsdiagram med album på y-axeln och valens på x-axeln. dat_small &lt;- dat %&gt;% filter(artist_name == &quot;Rihanna&quot;, album_type == &quot;album&quot;) %&gt;% mutate(Decade = floor(album_release_year / 10) * 10, Decade = as.character(Decade), album_name = reorder(album_name, album_release_year)) # Funktionen reorder() ordnar en vektor efter en annan. Här ordnas album efter release-år. g &lt;- ggplot(dat_small, aes(valence, album_name, color = Decade, text = track_name)) + geom_point() g Ändra gärna artist på lämpligt ställe. Vad måste läggas till för en interaktiv version av samma graf? Hemsidan https://plotly.com/r/ innehåller fler exempel för den som är intresserad. 3.9 Bonus: Warming stripes Warming stripes har sedan de först introducerades av Ed Hawking 2018 blivit en vanlig illustration av temperaturökning. I en warming stripe-graf anges varje år av en stapel och stapels färg ges av ett temperaturmått, vanligen årets medeltemperatur. I ggplot-terminologi har vi geometrier (staplar eller kolumner) med en x-position som ges av år och en ifylld färg som ges av temperatur. För att göra en graf behöver vi data över temperaturer. Följande rad hämtar temperaturdata från Stockholm. Källa: https://miljobarometern.stockholm.se/klimat/klimat-och-vaderstatistik/medeltemperatur/ dat_temp &lt;- read_csv(&quot;https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Temperatur%2C%20Stockholm.csv&quot;) Vi skapar nu en graf, som alltså ska ha en x-axeln given av år (Year) och ifylld färg som ges av temperatur (Value). Höjden ska vara densamma för alla staplar, men det spelar ingen roll vad den är (så länge den inte är noll). ggplot(dat_temp, aes(x = Year, y = 1, fill = Value)) + geom_col() Uppgift 3.23 (Staplar utan mellanrum) Ett första problem är att staplarna inte fyller ytan. Man kan styra staplars bredd med argumentet width, t.ex. ggplot(dat_temp, aes(x = Year, y = 1, fill = Value)) + geom_col(width = 0.1) Hitta ett värde för width som ger staplar utan mellanrum. Uppgift 3.24 (Färgval) Ett andra problem är att ggplots grundval för färger är från svart till blått. För klassiska warming stripes vill vi ha en skala från blått till rött. Färgerna i en skala ändras med särskilda scale_()-funktioner. En färgskala för ifylld färg kan sättas med scale_fill_gradientn(), till exempel ggplot(dat_temp, aes(x = Year, y = 1, fill = Value)) + geom_col(width = 0.1) + scale_fill_gradientn(colours = c(&quot;darkgreen&quot;, &quot;blue&quot;, &quot;white&quot;, &quot;yellow&quot;, &quot;purple&quot;)) Välj färger som ger en naturlig skala från blått till rött. Funktionen colors() ger valbara färger i R. Några möjliga val kan vara darkblue, blue, white, red, salmon, darkred, steelblue och skyblue. Uppgift 3.25 (Enkel graf) Slutligen brukar warming stripes presenteras med så lite kringinformation som möjligt. I ggplot kan grafelement tas bort med theme(). Här är som exempel en graf utan y-axel, tickmärken och legend. ggplot(dat_temp, aes(x = Year, y = Value)) + geom_line() + theme(axis.title = element_blank(), legend.position = &quot;none&quot;, plot.background = element_blank(), panel.background = element_blank(), axis.text.y = element_blank(), axis.ticks = element_blank()) Använd temat från exemplet för att skapa en enklare version av grafen från föregående uppgift. 3.10 Valfria hemuppgifter Uppgift 3.26 (Installera R) Gå till https://www.r-project.org/ och installera R på ditt hemma-system. Instruktioner finns i R-anvisningarnas kapitel Installation. Uppgift 3.27 (Installera RStudio) Gå till https://www.rstudio.com/ och installera RStudio på ditt hemma-system. Instruktioner finns i R-anvisningarnas kapitel Installation. Uppgift 3.28 (Öppna RStudio) Öppna skriptet till datorövning 1 i RStudio. Notera om något ser annorlunda ut mot hur det såg ut i datorsal. Uppgift 3.29 (Cheat sheets) I början av datorövning 1 plockade vi upp en hemsida med cheat sheets - korta instruktioner och guider till specifika R-paket. Vi kan hitta några av dem på https://www.rstudio.com/resources/cheatsheets/. Ladda ner guiden till ggplot2. Hur många olika theme_()-funktioner (som t.ex. theme_bw()) beskrivs i guiden? Vad gör en theme_-funktion? Uppgift 3.30 (Timothée Chalamet) Hitta klippet där skådespelaren Timothée Chalamet sjunger en sång om statistik. Uppskatta spårets dansbarhet och valens på en skala från noll till ett. Fundera på om det är rimligt att sätta en siffra på dansbarhet och valens. "],["datorövning-2.-beskrivande-statistik.html", "Kapitel 4 Datorövning 2. Beskrivande statistik 4.1 Repetition från datorövning 1 4.2 Import av data från en Excelfil 4.3 Sammanfattande lägesmått 4.4 Sammanfattande spridningsmått 4.5 Ordna upp beskrivande statistik och exportera 4.6 Stegvis beräkning av varians 4.7 Kumulativt medelvärde 4.8 Darwin-exempel 4.9 Bonus. Tredimensionella grafer med plotly 4.10 Valfria hemuppgifter", " Kapitel 4 Datorövning 2. Beskrivande statistik Datorövning 2 handlar om beräkning av beskrivande statistik i R. Efter övningen ska vi kunna Importera data från en excelfil, Beräkna lämpliga lägesmått för en variabel, Beräkna lämpliga spridningsmått för en variabel, Konstruera grafer som jämför två eller flera gruppers läge och spridning. 4.1 Repetition från datorövning 1 När man arbetar i R är det klokt att använda ett avancerat gränssnitt som RStudio och att skriva sin kod i ett separat skript. I RStudio kan man starta ett nytt skript genom Ctrl + Shift + N. Mycket funktionalitet i R ligger i tilläggspaket (Packages). Paket måste installeras första gången de används och laddas varje session de används, t.ex. # install.packages(&quot;tidyverse&quot;) library(tidyverse) # Ger ett felmeddelande om paketet inte installerats tidigare. Data läses in med import-funktioner där valet av funktion beror på typen av fil. Importerad data sparas som ett objekt i R genom assign-pilen &lt;-. dat &lt;- read_csv(&quot;https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Spotify_data.csv&quot;) dat ## # A tibble: 76,622 × 24 ## artist_name album_name track_number track_name album_type album_release_d… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 100 gecs 1000 gecs an… 1 money mac… album 2020-07-10 ## 2 100 gecs 1000 gecs an… 2 ringtone … album 2020-07-10 ## 3 100 gecs 1000 gecs an… 3 745 stick… album 2020-07-10 ## 4 100 gecs 1000 gecs an… 4 gec 2 Ü (… album 2020-07-10 ## 5 100 gecs 1000 gecs an… 5 hand crus… album 2020-07-10 ## 6 100 gecs 1000 gecs an… 6 800db clo… album 2020-07-10 ## 7 100 gecs 1000 gecs an… 7 stupid ho… album 2020-07-10 ## 8 100 gecs 1000 gecs an… 8 ringtone … album 2020-07-10 ## 9 100 gecs 1000 gecs an… 9 xXXi_wud_… album 2020-07-10 ## 10 100 gecs 1000 gecs an… 10 745 stick… album 2020-07-10 ## # … with 76,612 more rows, and 18 more variables: album_release_year &lt;dbl&gt;, ## # danceability &lt;dbl&gt;, energy &lt;dbl&gt;, key &lt;dbl&gt;, loudness &lt;dbl&gt;, mode &lt;dbl&gt;, ## # speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, ## # liveness &lt;dbl&gt;, valence &lt;dbl&gt;, tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, ## # explicit &lt;lgl&gt;, type &lt;chr&gt;, key_name &lt;chr&gt;, mode_name &lt;chr&gt;, key_mode &lt;chr&gt; Funktioner agerar på objekt och ger något utfall. Här beräknas medeltempot med funktionen mean(). Dollartecknet används för att ange en specifik kolumn i dataobjektet. Funktioner styrs av möjliga argument - här används na.rm för att ange att saknade värden inte ska tas med i beräkningen mean(dat$tempo, na.rm = T) ## [1] 119.0361 Funktionerna filter() och select() kan användas för att välja kolumner och rader. Funktioner kan länkas samman med en pipe %&gt;% för att skapa sekvenser av funktioner. Man kan tänka på pipen som och sen. dat %&gt;% # ta datan, och sen filter(artist_name == &quot;Tame Impala&quot;, tempo &gt; 170) %&gt;% # ta ut rader där artisten är Tame Impala och tempot är större än 170, och sen select(artist_name, track_name, tempo) # ta ut kolumnerna artist_name, track_name och tempo ## # A tibble: 8 × 3 ## artist_name track_name tempo ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Tame Impala Lost In Yesterday 183. ## 2 Tame Impala Yes I&#39;m Changing 180. ## 3 Tame Impala Led Zeppelin 184. ## 4 Tame Impala Borderline - Blood Orange Remix 174. ## 5 Tame Impala Guilty Conscience - Tame Impala Remix Extended 192. ## 6 Tame Impala Guilty Conscience - Tame Impala Remix 192. ## 7 Tame Impala Guilty Conscience - Tame Impala Remix Instrumental 192. ## 8 Tame Impala Guilty Conscience - Tame Impala Remix 192. Funktionen summarise() ger ett sammanfattande mått (som mean() för medelvärde eller sum() för summa) för någon eller några variabler. Funktionen group_by() kan användas för att göra beräkningen efter någon gruppering. dat %&gt;% group_by(artist_name) %&gt;% summarise(Antal_spår = n(), Medeltempo = mean(tempo), Maxdansbarhet = max(danceability)) ## # A tibble: 363 × 4 ## artist_name Antal_spår Medeltempo Maxdansbarhet ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 100 gecs 50 135. 0.92 ## 2 A Sunny Day In Glasgow 106 121. 0.63 ## 3 A Tribe Called Quest 139 101. 0.954 ## 4 A$AP Rocky 162 122. 0.945 ## 5 Abe Vigoda 68 136. 0.57 ## 6 Actress 206 118. 0.939 ## 7 Adrianne Lenker 61 125. 0.758 ## 8 Against All Logic 26 118. 0.92 ## 9 Aldous Harding 80 111. 0.914 ## 10 Alex G 179 122. 0.807 ## # … with 353 more rows Slutligen tittade vi på grafer med ggplot2-paketet. En ggplot byggs upp med tre grundelar: data, geometrier (grafens objekt och former), och aesthetics (utseende och placering av geometrierna). I ett enkelt spridningsdiagram är data två numeriska variabler, geometrierna är punkter, och punkternas placering ges av en x-koordinat och en y-koordinat. Ytterligare aesthetics kan vara punkternas färger (color) och storlek (size). dat_small &lt;- dat %&gt;% filter(artist_name == &quot;The Weeknd&quot;) ggplot(dat_small, aes(tempo, danceability, size = valence, color = mode_name)) + geom_point() 4.2 Import av data från en Excelfil Inom vetenskapen är Excel, på gott och ont, det vanligaste filformatet för mindre datamängder. Till den här delen ska vi arbeta med data från Gapminder, en stiftelse som sprider information om socio-ekonomisk utveckling och global hälsa. Uppgift 4.1 (Excelfil från Canvas) Hitta excelfilen Gapminder.xlsx på Canvas och ladda ner den. Hitta mappen som filen laddats ned till. I R kan man läsa in data från en Excel-fil med funktionen read_excel() från paketet readxl. Som argument till funktionen sätts filens sökväg - dess placering på hårddisken. Stycket nedan importerar från en excelfil som ligger på hårddisken C: i mappen Downloads, under User_name, under Users. library(readxl) # Ladda readxl gapminder &lt;- read_excel(&quot;C:/Users/User_name/Downloads/Gapminder.xlsx&quot;) gapminder Uppgift 4.2 (Importera från excelfil) Vad är sökvägen för den nedladdade filen Gapminder.xlsx? Gör lämplig ändring i koden ovan för att läsa in data från den filen. Notera att R använder högerlutande snedstreck /, så om en kopierad sökväg har vänster-snedstreck måste de ändras. Kontrollera att datan blivit korrekt inläst genom att köra objektnamnet gapminder. En R-session har alltid en grundmapp, ett Working directory. Man kan se vilken mapp det är genom att köra getwd() En filsökväg kan anges antingen som en fullständig sökväg, som ovan, eller relativt working directory. Om man till exempel har en fil Gapminder.xlsx som ligger i en mapp Data som i sin tur ligger i working directory, kan man importera data från filen med gapminder &lt;- read_excel(&quot;Data/Gapminder.xlsx&quot;) gapminder ## # A tibble: 1,704 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # … with 1,694 more rows Uppgift 4.3 (Working directory) Identifiera working directory för din nuvarande Rs-session genom att köra getwd(). RStudio har också en inbyggd funktionalitet för att importera data. Man kan hitta den genom att gå till Environment-fliken och sedan Import Dataset. Det kan vara en bra hjälp, i synnerhet om man vill sätta datatyp för någon specifik kolumn. Om du inte har tillgång till Canvas kan Gapminder-datan alternativt hämtas från paketet Gapminder. # install.packages(&quot;gapminder&quot;) library(gapminder) gapminder 4.3 Sammanfattande lägesmått Den importerade datan ger medellivslängd, populationsstorlek och bnp per capita per land och år. Vi kan börja med att producera en bubbelgraf över datan - en av de presentationer Gapminder ofta använder. En bubbelgraf är ett spridningsdiagram där punktens storlek beror på en tredje variabel. ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = continent)) + geom_point() + facet_wrap(~ year) En interaktiv version kan vara bra om man vill identifiera någon punkt. g &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = continent, text = country)) + geom_point() + facet_wrap(~ year) library(plotly) ggplotly(g) Under föreläsningen såg vi exempel på två lägesmått: medelvärdet (egentligen det aritmetiska medelvärdet) och medianen. De har bägge enkla funktioner i R: mean() respektive median(). Vi plockar ut en variabel ur datan och beräknar bägge. gdpPercap &lt;- gapminder$gdpPercap mean(gdpPercap) ## [1] 7215.327 median(gdpPercap) ## [1] 3531.847 Samma sak kan göras med en pipe %&gt;% och summarise(). gapminder %&gt;% summarise(Mean = mean(gdpPercap), Median = median(gdpPercap)) ## # A tibble: 1 × 2 ## Mean Median ## &lt;dbl&gt; &lt;dbl&gt; ## 1 7215. 3532. Uppgift 4.4 (Lägesmått av livslängd) Gör lämpliga ändringar i exemplet ovan för att beräkna lägesmått för medellivslängd (lifeExp). Den andra lösningen, med en pipe och summarise(), kan enkelt utvecklas med ett group_by()-steg för att beräkna medel och median per någon grupp, t.ex. per år. gapminder %&gt;% group_by(year) %&gt;% summarise(Mean = mean(gdpPercap), Median = median(gdpPercap)) ## # A tibble: 12 × 3 ## year Mean Median ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1952 3725. 1969. ## 2 1957 4299. 2173. ## 3 1962 4726. 2335. ## 4 1967 5484. 2678. ## 5 1972 6770. 3339. ## 6 1977 7313. 3799. ## 7 1982 7519. 4216. ## 8 1987 7901. 4280. ## 9 1992 8159. 4386. ## 10 1997 9090. 4782. ## 11 2002 9918. 5320. ## 12 2007 11680. 6124. Uppgift 4.5 (Lägesmått per kontinent) Gör lämpliga ändringar i exemplet ovan för att beräkna lägesmått per kontinent. Vad måste läggas till för att också beräkna maximum och minimum per kontinent (funktionerna max() och min())? Uppgift 4.6 (Upprepade mätningar) Finns det några problem med att beräkna medelvärde per kontinent på den här datan? (Jag kan se minst två.) I vetenskapliga publikationer redovisas medelvärden ofta med ett stapeldiagram. Som exempel ges staplar för medelvärdet av bnp per kontinent för 2007. dat_gdp_2007 &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise(Mean = mean(gdpPercap)) ggplot(dat_gdp_2007, aes(continent, Mean)) + geom_col() För att få lite mer information kan man lägga till de individuella punkterna. ggplot(dat_gdp_2007, aes(continent, Mean)) + geom_col() + geom_point(aes(continent, gdpPercap), data = gapminder %&gt;% filter(year == 2007)) Eftersom geom_point() här bygger på annan data än kolumnerna från geom_col() anger vi en ny aes()-funktionen och sätter argumentet data. Det kan också vara informativt att använda geom_text() för länderna. Etiketterna sätts med argumentet label i aes(). (Om man oroar sig för överlappande etiketter och letar efter lite överkurs kan man titta på paketet ggrepel.) ggplot(dat_gdp_2007, aes(continent, Mean)) + geom_col() + geom_text(aes(continent, gdpPercap, label = country), data = gapminder %&gt;% filter(year == 2007), size = 2) Uppgift 4.7 (Graf för livslängd) Gör om stapeldiagrammet. Denna gång med livslängd (lifeExp) istället för bnp per capita (gdpPercap). 4.4 Sammanfattande spridningsmått Under föreläsningarna såg vi några mått på spridning: varians, standardavvikelse och kvartilavstånd (IQR, inter-quartile range). De har alla motsvarande funktioner i R (var(), sd(), och IQR()) som kan användas på samma sätt som funktionerna för lägesmått. gdpPercap &lt;- gapminder$gdpPercap var(gdpPercap) ## [1] 97169410 sd(gdpPercap) ## [1] 9857.455 IQR(gdpPercap) ## [1] 8123.402 Alternativt med en pipe och summarise(). gapminder %&gt;% summarise(Varians = var(gdpPercap), Standardavvikelse = sd(gdpPercap), Kvartilavstånd = IQR(gdpPercap)) ## # A tibble: 1 × 3 ## Varians Standardavvikelse Kvartilavstånd ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 97169410. 9857. 8123. Lösningen med pipe och summarise() kan som tidigare utvecklas med group_by(). gapminder %&gt;% group_by(year) %&gt;% summarise(Varians = var(gdpPercap), Standardavvikelse = sd(gdpPercap), Kvartilavstånd = IQR(gdpPercap)) ## # A tibble: 12 × 4 ## year Varians Standardavvikelse Kvartilavstånd ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1952 86882249. 9321. 3049. ## 2 1957 97410232. 9870. 3946. ## 3 1962 75123173. 8667. 4650. ## 4 1967 65534132. 8095. 5925. ## 5 1972 112665135. 10614. 8252. ## 6 1977 69931225. 8362. 9847. ## 7 1982 59812359. 7734. 10985. ## 8 1987 68695607. 8288. 10667. ## 9 1992 81574244. 9032. 9414. ## 10 1997 103459275. 10171. 10656. ## 11 2002 124414278. 11154. 11950. ## 12 2007 165377988. 12860. 16384. Uppgift 4.8 (Graf för livslängd) Gör lämpliga ändringar i det sista exempel för att istället beräkna spridningsmått för livslängd. Vi avslutar med tre vanliga illustrationer av vetenskaplig data - ett linjediagram med felstaplar, ett stapeldiagram med felstaplar, och ett lådagram. För linjediagrammet beräknar vi medelvärdet och spridningsmått för bnp över år och kontinent. Som spridningsmått använder vi medelfelet, vilket beräknas som standardavvikelse delat på roten ur antalet observationer. dat_sum &lt;- gapminder %&gt;% group_by(year, continent) %&gt;% summarise(Mean = mean(gdpPercap), SE = sd(gdpPercap) / sqrt(n())) dat_sum ## # A tibble: 60 × 4 ## # Groups: year [12] ## year continent Mean SE ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1952 Africa 1253. 136. ## 2 1952 Americas 4079. 600. ## 3 1952 Asia 5195. 3244. ## 4 1952 Europe 5661. 569. ## 5 1952 Oceania 10298. 258. ## 6 1957 Africa 1385. 157. ## 7 1957 Americas 4616. 662. ## 8 1957 Asia 5788. 3396. ## 9 1957 Europe 6963. 671. ## 10 1957 Oceania 11599. 649. ## # … with 50 more rows Med ggplot2 kan vi bygga ett linjediagram med geom_line() och lägga till felstaplar med geom_errorbar(). Den senare behöver aes()-argument för ymin och ymax - nedre och övre del av felstapeln. Vi sätter dem till medelvärdet minus respektive plus ett medelfel. ggplot(dat_sum, aes(year, Mean, color = continent)) + geom_line() + geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE)) Uppgift 4.9 (Bredd) Felstaplarna från geom_errorbar() har väldigt breda ändar. Använd hjälpsidan för geomet ?geom_errorbar, i synnerhet exemplen längst ned, och se om det går att ändra bredden. En graf med staplar och felstaplar kan konstrueras på ett likande sätt. Följande exempel visar staplar över livslängd per kontinent. Felstapeln ges av standardavvikelsen. dat_sum &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise(Mean = mean(lifeExp), SD = sd(lifeExp)) dat_sum ## # A tibble: 5 × 3 ## continent Mean SD ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 54.8 9.63 ## 2 Americas 73.6 4.44 ## 3 Asia 70.7 7.96 ## 4 Europe 77.6 2.98 ## 5 Oceania 80.7 0.729 Vi bygger en ggplot med geom_col() och geom_errorbar(). Felstapels konstruktion kan anges i en notis med funktionen labs(). ggplot(dat_sum, aes(continent, Mean, fill = continent)) + geom_col()+ geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD)) + labs(title = &quot;Average life expectancy by continent, 2007&quot;, caption = &quot;Errorbars given by mean +/- standard deviation. Source: Gapminder&quot;) Uppgift 4.10 (Staplar för 1982) Gör lämpliga ändringar i exempel ovan för att konstruera ett stapeldiagram med felstaplar för året 1982 och variabeln gdpPercap. Ett lådagram anger fördelningen av en variabel genom att illustrera minimum, maximum och kvartiler. Kvartiler är mått som delar en datamängd i fyra lika stora delar (så att en fjärdedel ligger under första kvartilen, en fjärdedel mellan första och andra kvartil, och så vidare). Med ggplot2 kan vi bygga ett lådagram med geom_boxplot(). Exempel ger en låda per år och kontinent. ggplot(gapminder, aes(year, lifeExp, fill = continent, group = year)) + geom_boxplot() + facet_wrap(~ continent) Uppgift 4.11 (Group-argumentet) I lådagrammet används argumentet group. Vad gör det? Vad händer om man tar bort det? 4.5 Ordna upp beskrivande statistik och exportera Efter att ha beräknat någon beskrivande statistik kan det vara bra att titta på hur resultaten kan snyggas upp och exporteras i något lämpligt format. Ta den tabell med medelvärden vi producerade i ett tidigare exempel. dat_sum &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise(Mean = mean(lifeExp), SD = sd(lifeExp)) dat_sum ## # A tibble: 5 × 3 ## continent Mean SD ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 54.8 9.63 ## 2 Americas 73.6 4.44 ## 3 Asia 70.7 7.96 ## 4 Europe 77.6 2.98 ## 5 Oceania 80.7 0.729 Ett vanligt skrivsätt för medelvärde och standardavvikelse är som m ± sd. Vi kan använda funktionen paste() för att slå ihop kolumner till en sammanhängande text. dat_sum %&gt;% mutate(mean_plus_minus_sd = paste(Mean, &quot;±&quot;, SD)) ## # A tibble: 5 × 4 ## continent Mean SD mean_plus_minus_sd ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Africa 54.8 9.63 54.8060384615385 ± 9.63078067196179 ## 2 Americas 73.6 4.44 73.60812 ± 4.44094763085538 ## 3 Asia 70.7 7.96 70.7284848484849 ± 7.96372447069057 ## 4 Europe 77.6 2.98 77.6486 ± 2.9798126601609 ## 5 Oceania 80.7 0.729 80.7195 ± 0.729027091403335 Vi måste avrunda medelvärdet och standardavvikelsen först. Det kan man göra med round(), vars argument är den variabel man vill avrunda och antalet decimaler man vill avrunda till. dat_sum &lt;- dat_sum %&gt;% mutate(mean_plus_minus_sd = paste(round(Mean, 1), &quot;±&quot;, round(SD, 1))) Uppgift 4.12 (Tappade nollor) Utfallet ovan är nära men inte heller riktigt vad som behövs. I de fall där funktionen avrundat till en nolla har decimal tappats. Hur kan man visa en avslutande nolla? Följande tråd på StackOverflow besvarar samma fråga. https://stackoverflow.com/questions/42105336/how-to-round-a-number-and-make-it-show-zeros Försök använda kod därifrån för att lägga till en avslutande nolla. Objekt kan exporteras från R på liknande som det importeras - med särskilda exportfunktioner (write-funktioner) beroende på filtyp. För att exportera till en csv-fil man man anvnäda write_csv(). Ingående argument är det objekt man vill exportera och den fil man vill exportera till. R ger ingen varning om man skriver över en existerande fil, så var lite försiktiga här. Precis som vid import använda R working directory om inget annat anges. Följande exporterar objektet dat_sum till en csv-fil Exporterad data från R.csv i working directory. getwd() write_csv(dat_sum, &quot;Exporterad data från R.csv&quot;) Därifrån skulle man kunna öppna filen i något kalkylprogram, snygga till layouten, och sedan klippa in i ett textdokument. 4.6 Stegvis beräkning av varians Det vara nyttigt att göra en stegvis beräkning av varians (och standardavvikelse) för att få en lite bättre förståelse av vad det faktiskt beskriver. Nedan ges en slumpmässig exempeldata med fem observationer. Om du har en tärning från datorövning 1 kan du med fördel kasta den nu, och ersätta värdena med dina egna utfall dat &lt;- data.frame(Rad = c(1,2,3,4,5), x = c(6,3,2,3,5)) dat ## Rad x ## 1 1 6 ## 2 2 3 ## 3 3 2 ## 4 4 3 ## 5 5 5 En variansberäkning har följande steg, beräkna medelvärdet, beräkna utfallet minus medelvärdet för varje observation, ta differenserna i kvadrat, summera kvadraterna, dela summan med antalet observationer minus ett. Vi har tidigare sett beräkningen av medelvärden med mean(). En skillnad mot tidigare är att vi gör det i ett mutate() steg istället för summarise(), eftersom vi vill ha kvar den tidigare strukturen med flera rader. dat &lt;- dat %&gt;% mutate(Medelvärde = mean(x)) dat ## Rad x Medelvärde ## 1 1 6 3.8 ## 2 2 3 3.8 ## 3 3 2 3.8 ## 4 4 3 3.8 ## 5 5 5 3.8 Därefter tar vi differensen mellan observationernas värden och medelvärdet. dat &lt;- dat %&gt;% mutate(Differenser = x - Medelvärde) dat ## Rad x Medelvärde Differenser ## 1 1 6 3.8 2.2 ## 2 2 3 3.8 -0.8 ## 3 3 2 3.8 -1.8 ## 4 4 3 3.8 -0.8 ## 5 5 5 3.8 1.2 Därefter tar vi kvadrater av differenserna. För att ange en kvadrat används symbolen ^2, t.ex. 3^2 för tre i kvadrat. dat &lt;- dat %&gt;% mutate(Kvadrater = Differenser^2) dat ## Rad x Medelvärde Differenser Kvadrater ## 1 1 6 3.8 2.2 4.84 ## 2 2 3 3.8 -0.8 0.64 ## 3 3 2 3.8 -1.8 3.24 ## 4 4 3 3.8 -0.8 0.64 ## 5 5 5 3.8 1.2 1.44 Först i nästa steg summerar vi kvadraterna. dat_sum &lt;- dat %&gt;% summarise(Kvadratsumma = sum(Kvadrater)) dat_sum ## Kvadratsumma ## 1 10.8 Som avslutande steg delar vi kvadratsumman med antalet observationer minus ett. För fem observationer delar vi alltså med fyra. dat_sum %&gt;% mutate(Varians = Kvadratsumma / 4) ## Kvadratsumma Varians ## 1 10.8 2.7 Vi kan se om vi fått rätt genom att beräkna variansen med funktionen var(). var(dat$x) # Dollartecken för att ta ut kolumnen x i objektet dat ## [1] 2.7 4.7 Kumulativt medelvärde Om man har data som av någon anledning samlas in i sekvens kan det vara intressant att beräkna och illustrera den med ett kumulativt medelvärde. En serie med kumulativa medelvärden beräknas genom att för varje nytt värde ta medelvärden av de värden man hittills samlat in - vid tio värden tar man medelvärdet av de tio, vid elva värden medelvärdet av de elva, och så vidare. Med de tärningsvärden vi hade innan kan vi beräkna ett kumulativt medelvärde genom att först beräkna summan med cumsum() och sedan dela på antalet kast. För att förenkla beräkningen av antalen tar vi fram sekvensen med antal kast i ett mutate()-steg. dat_dice &lt;- data.frame(Utfall = c(6,3,2,3,5)) %&gt;% mutate(Kast = 1:n()) dat_dice ## Utfall Kast ## 1 6 1 ## 2 3 2 ## 3 2 3 ## 4 3 4 ## 5 5 5 dat_dice &lt;- dat_dice %&gt;% mutate(`Kumulativ summa` = cumsum(Utfall), `Kumulativt medelvärde` = `Kumulativ summa` / Kast) dat_dice ## Utfall Kast Kumulativ summa Kumulativt medelvärde ## 1 6 1 6 6.000000 ## 2 3 2 9 4.500000 ## 3 2 3 11 3.666667 ## 4 3 4 14 3.500000 ## 5 5 5 19 3.800000 Om beräkning inte är uppenbar här, ta någon minut för att förstå den. Uppgift 4.13 (Kumulativt medelvärde) Vad ska läggas till för att stycket nedan ska ge en linjegraf över medelvärdet? ggplot(dat_dice, aes(x = Kast, y = ___)) + ___() Uppgift 4.14 (Fler tärningskast) Kasta din tärning ytterligare några gånger, gärna på en mjuk yta. Fyll i dina utfall och gör grafen från föregående uppgift. Kan man se en tendens för medelvärdet att minska i varians vid fler kast? dat_dice &lt;- data.frame(Utfall = c(___)) %&gt;% mutate(Kast = 1:n(), `Kumulativ summa` = cumsum(Utfall), `Kumulativt medelvärde` = `Kumulativ summa` / Kast) dat_dice Uppgift 4.15 (Kumulativ frekvens) Om man vill titta på andelen gånger ett visst utfall inträffat talar man om kumulativ frekvens snarare än kumulativt medelvärde. Använd stycket nedan för att titta på andelen gånger utfallet varit en etta (ett positivt utfall, i begreppets kliniska mening). Om ett inte är ett möjligt utfall på din tärning, ändra ettan till något mer lämpligt. dat_dice &lt;- data.frame(Utfall = c(___)) %&gt;% mutate(Kast = 1:n(), `Positivt utfall` = Utfall == 1, `Kumulativt antal` = cumsum(`Positivt utfall`), `Kumulativ frekvens` = `Kumulativt antal` / Kast) dat_dice ggplot(dat_dice, aes(x = Kast, y = `Kumulativ frekvens`)) + geom_line() 4.8 Darwin-exempel Uppgift 4.16 (Stapeldiagram med felstaplar) Darwins studie gav följande data: Självbefruktade Korsbefruktade 17.4 23.5 20.4 12.0 20.0 21.0 20.0 22.0 18.4 19.1 18.6 21.5 18.6 22.1 15.3 20.4 16.5 18.3 18.0 21.6 16.3 23.3 18.0 21.0 12.8 22.1 15.5 23.0 18.0 12.0 Konstruera ett stapeldiagram med felstaplar där stapelns höjd ges av medelvärdet inom gruppen och felstapelns längd av standardavvikelsen inom gruppen. Datan finns tillgänglig i arket Darwin i excelfilen Uppgiftsdata.xlsx. Exceldata kan läsas in med funktionen read_excel från paketet readxl. Lösningsförslag 4.1 (Stapeldiagram med felstaplar) Felstaplar kan konstrueras genom att beräkna medelvärde och standardavvikelse, och sedan pipa (%&gt;%) in i en plot där staplar konstrueras med geom_bar och felstaplar med geom_errorbar. dat &lt;- readxl::read_excel(&quot;Data/Uppgiftsdata.xlsx&quot;, sheet = &quot;Darwin&quot;) dat %&gt;% group_by(Metod) %&gt;% summarise(m = mean(Utfall), s = sd(Utfall)) %&gt;% ggplot(aes(Metod, m)) + geom_bar(stat = &quot;identity&quot;, width = 0.3, col = &quot;black&quot;, fill = &quot;white&quot;) + geom_errorbar(aes(ymin = m - s, ymax = m + s), width = 0.1) + labs(caption = &quot;Felstapel anger +/- en standardavvikelse&quot;) Det är inte alltid klart vilket spridningsmått felstaplarna illusterar (vanliga alternativ är standardavvikelsen, medelfelet (standardavvikelsen delat på roten ur stickprovsstorleken) och konfidensintervallet). Det är därför god praxis att skriva ut vad felstaplarna anger. 4.9 Bonus. Tredimensionella grafer med plotly Förra gången anvnäde vi paketet plotly för att göra en interaktiv graf. Paketet har också funktioner för 3d-grafer. Börja med att ladda paketet. library(plotly) Vi börjar med ett enkelt exempel på en 3d-graf med lite skapad data. dat_ex &lt;- data.frame(Var1 = c(1,2,3), Var2 = c(3,1,2), Var3 = c(2,3,1), Type = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) dat_ex plot_ly(dat_ex, x = ~Var1, y = ~Var2, z = ~Var3, color = ~Type) %&gt;% add_markers() Om grafen inte kommer upp direkt kan det fungera att trycka på den lilla ikonen med ett fönster och en pil i Viewer-fliken. Grafen ska då öppnas i en webbläsare. Syntaxen till plot_ly() är inte helt olik ggplot(). Först anges datan, därefter argument för x- y-, och z-koordinater. Notera tilde-tecknet ~ före variabelnamnen. Eventuell färg sätts med color. Efter det lägger man till punkter (här markers) med en pipe in i add_markers(). Vi vill göra en liknande graf med gapminder-datan, men får börja med att filtrera på ett visst år. Uppgift 4.17 (Filtrera för år) Vad måste läggas till i funktionen nedan för att filtrera för data där året är 2007? dat_2007 &lt;- gapminder %&gt;% ___(year == ___) Vi kan nu konstruera en 3d-graf med datan. Uppgift 4.18 (Gapminder i 3d) Vad måste läggas till i funktionen nedan för en 3d-graf med befolkningsmängd (pop) på x-axeln, livslängd (lifeExp) på y-axeln, bnp per capita (gdpPercap) på z-axeln, och färg efter kontinent (continent)? För att kunna identifiera specifika länder kan man också sätta argumentet text. plot_ly(___, x = ~___, y = ~___, z = ~___, color = ~___, text = ~country) %&gt;% add_markers() Uppgift 4.19 (Log-transformationer) Inom statistiken är det vanligt att transformera variabler för att ta bort extremeffekter och visa på specifika dataegenskaper. En vanlig transform är att logaritmera ett värde, vilket innebär att man istället för att använda det ursprungliga värdet använder exponenten i någon bas (ofta basen tio). Ta till exempel värdet 10000, dess tio-logaritm är 4, eftersom 10 upphöjt i 4 är 10000. Logaritmer är vanliga vid data med extremvärden. Grafen i uppgiften ovan präglas mycket av skillnader i bnp och befolkningsstorlek. Testa att tio-logaritmera variablerna och se om det blir en mer eller mindre överskådlig graf. Logaritmen kan göras genom att byta den ursprungliga variabeln mot en variabel transformerad med log10(). Fyll i stycket nedan. plot_ly(___, x = ~log10(___), y = ~log10(___), z = ~___, color = ~___, text = ~country) %&gt;% add_markers() Uppgift 4.20 (Följa ett land) Likt en ggplot kan man lägga till graf-element. Här använder man dock en pipe för lägga till ett nytt element. Fyll i kodstycket nedan. Vad, om något, har lagts till i grafen? plot_ly(___, x = ~log10(___), y = ~log10(___), z = ~___, color = ~___, text = ~country) %&gt;% add_markers() %&gt;% add_lines(data = gapminder %&gt;% filter(country == &quot;Costa Rica&quot;)) Uppgift 4.21 (Spotify 3d) Som avslutning återvänder vi till spotify-datan från datorövning 1. Fyll i stycket nedan för att skapa en graf med tempo, dansbarhet och valens (tempo, danceability, valence) på axlarna, storlek efter energi (energy) och text efter spårnamn (track_name). Filtrera på valfri artist. Använd unique(dat_spot$artist_name) för att se tillgängliga artister. dat_spot &lt;- read_csv(&quot;https://raw.githubusercontent.com/adamflr/ST0060-2022/main/Data/Spotify_data.csv&quot;) dat_small &lt;- dat_spot %&gt;% filter(artist_name == &quot;Weyes Blood&quot;) plot_ly(dat_small, x = ~___, y = ~___, z = ~___, size = ~___, text = ~___) %&gt;% add_markers() 4.10 Valfria hemuppgifter Uppgift 4.22 (TidyTuesday) TidyTuesday är ett R-kopplat pedagogiskt projekt som varje vecka publicerar ett nytt dataset och utmanar allmänheten att skapa bästa möjliga visualisering av data. Resultaten publiceras vanligen på Twitter med #TidyTuesday. På sidan https://github.com/rfordatascience/tidytuesday/tree/master/data/2022 finns en tabell med dataset publicerade under 2022. Gå igenom listan, hitta ett intressant fall och läs informationen om det (genom att klicka på länken). Är det möjligt att förstå beskrivningen av datan? Uppgift 4.23 (r/dataisbeautiful) Gå till reddit-sidan dataisbeautiful. Välj en graf som verkar tydlig eller vacker eller intressant. Försök förstå den i termer av data (vilken information ligger bakom grafen), geometrier (vilka geometriska former är synliga i grafen, punkter, linjer, staplar), och estetik (vilka datavariabler styr hur geometrin ser ut och var den är placerad). Uppgift 4.24 (More or Less: Behind the Stats) BBC Radio har ett program om statistik, se https://www.bbc.co.uk/programmes/p02nrss1. Lyssna på ett avsnitt. Sammanfatta det i haiku-form. Uppgift 4.25 (gganimate) Med paketet gganimate (https://gganimate.com/) kan man göra animationer av ggplot-grafer. Installera paketet med install.packages(\"gganimate\") och försök kör de exempel som ges på hemsidan. Uppgift 4.26 (Skumma ett paper) Hitta en vetenskaplig artikel i valfri tidskrift. Vilka läges- och spridningsmått kan du hitta? Vilka grafer? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
